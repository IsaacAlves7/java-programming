<a href="https://github.com/IsaacAlves7/java-programming"><img src="https://training.infnet.edu.br/wp-content/uploads/sites/18/2019/02/desenvolvedor-java.jpg"/></a>

# <a href="#"><img src="https://cdn.worldvectorlogo.com/logos/java-14.svg" height="37"></a> It's a repository of Java language programming ‚òï

[![.JAR](https://img.shields.io/badge/-script.jar-000000?style=social&logo=Java&logoColor=D77310)](#)
[![Oracle](https://img.shields.io/badge/-oci-000000?style=social&logo=Oracle&logoColor=red)](#)
[![Android](https://img.shields.io/badge/-Android-000000?style=social&logo=Android&logoColor=3DDC84)](#)
[![Spring](https://img.shields.io/badge/-Spring-000000?style=social&logo=Spring&logoColor=6DB33F)](#)
[![Spring Boot](https://img.shields.io/badge/-Spring_Boot-000000?style=social&logo=Spring-Boot&logoColor=6DB33F)](#)
[![Spring Security](https://img.shields.io/badge/-Spring_Security-000000?style=social&logo=Spring-Security&logoColor=6DB33F)](#)
[![Hibernate](https://img.shields.io/badge/-Hibernate-000000?style=social&logo=Hibernate&logoColor=59666C)](#)


<blockquote>I created this repository for my Java Full-Stack Development learning.</blockquote>

# üéí Prerequisites and repositories üìö
- Good domains in English;
- Programming logic;

<blockquote>‚ö†Ô∏è <b>Warning:</b> It's very important to install each one of components shown and to execute the codes on your own machine. Besides that, please note that repository is only focused in Java development, if you want to learn about HTML5, CSS3 or Java Frameworks i recommend to access another repositories, click on links bellow!</blockquote>

<a href="https://github.com/IsaacAlves7/java-programming"><div align="center"><img src="https://sd.keepcalms.com/i/keep-calm-and-code-java-2.png" height="217"/></div></a>

<hr>

# üêí Paradigmas de desenvolvimento de software üßí

<div align="center"><img src="https://user-images.githubusercontent.com/61624336/112900537-065ce480-90ba-11eb-86f7-f9006445876a.png"></div><br \>

Hoje em dia, o desenvolvimento de sistemas se baseia em v√°rios e diferentes paradigmas, tais como os listados a seguir:

- **Imperativo (Procedural)**: Segue sequ√™ncias de comandos ordenados segundo uma l√≥gica.
- **Funcional**: Trabalha com a divis√£o de problemas atrav√©s de fun√ß√µes, que resolvem separadamente problemas menores e que, ao serem organizados, resolvem o problema como um todo.
- **L√≥gico**: Voltado ao desenvolvimento de problemas de l√≥gica e usado em sistemas de intelig√™ncia computacional.
- **Orientado a Objetos (OO)**: Define um conjunto de classes para dividir o problema e realiza a intera√ß√£o entre as diferentes classes para tamb√©m resolver o problema como um todo.

----

<!--
https://miro.medium.com/max/1200/1*GCu4cNWIU1ElDbY7d4ycZw.png
https://refactoring.guru/images/patterns/languages/java.png
https://cdn.worldvectorlogo.com/logos/java-1.svg
https://cdn.worldvectorlogo.com/logos/java.svg
https://cdn.worldvectorlogo.com/logos/java-duke.svg
https://cdn.worldvectorlogo.com/logos/java-3.svg
https://www.educamundo.com.br/uploads/blog_posts/featured_images/java.png
https://blog.neomind.com.br/wp-content/uploads/2019/04/java-pago-e-agora.jpg
https://www.3way.com.br/wp-content/uploads/2017/08/programacao-java.jpg
https://cursosciatec.com.br/home/wp-content/uploads/2018/11/banner-java-pronto1.png
https://www.luiztools.com.br/wp-content/uploads/2017/04/Java-1-Introduction.png
https://us.123rf.com/450wm/kchung/kchung1812/kchung181200070/126832975-stock-vector-coffee-woodcut-style-illustration-on-kraft-paper-banner.jpg?ver=6
https://arquivo.devmedia.com.br/cursos/imagem/curso_preparando-o-ambiente-para-programar-em-java_2117.jpg
https://i.ytimg.com/vi/304GR-8f9c8/maxresdefault.jpg
https://arquivo.devmedia.com.br/cursos/imagem/curso_o-que-e-java_2028.png
-->

<h1>‚òï Tecnologia Java ‚ô®Ô∏è</h1>

<div align="center"><img src="https://cdn.worldvectorlogo.com/logos/java-100-pure.svg" height="270"></div><br \>

**Java** √© o ambiente computacional, ou plataforma, criada pela empresa estadunidense *Sun Microsystems*, e vendida para a *Oracle* depois de alguns anos. A plataforma permite desenvolver programas utilizando a linguagem de programa√ß√£o Java.

# ‚òï History of Java Language ‚òï
<div align="center"><img src="https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/apple/271/deciduous-tree_1f333.png" height="170" title="Oak, before of Java"><img src="https://cdn.worldvectorlogo.com/logos/java-duke.svg" height="170" title="Duke, the Java Mascot"><img src="https://cdn.worldvectorlogo.com/logos/java-1.svg" height="170"><img src="https://cdn.worldvectorlogo.com/logos/java.svg" height="170"></div><br \>

A tecnologia **Java** foi desenvolvida na d√©cada de 1990, a partir de um projeto pessoal de um funcion√°rio da **Sun Microsystems**. A ideia inicial estava ligada √† cria√ß√£o de uma linguagem de programa√ß√£o que pudesse ser utilizada em diferentes sistemas, alterando o paradigma de que uma aplica√ß√£o s√≥ poderia ser desenvolvida para uso em um √∫nico ambiente de hardware e sistema operacional, como era bastante comum na √©poca.

As grandes empresas desenvolviam suas aplica√ß√µes voltadas para seu ambiente de hardware e software (sistema operacional - SO), e estas aplica√ß√µes n√£o eram capazes de serem executadas em diferentes plataformas, principalmente de outros fabricantes. Se analisarmos a linguagem C, criada junto com o sistema operacional UNIX, temos uma biblioteca muito vasta de fun√ß√µes, mas poucas s√£o consideradas padr√£o para atender a diferentes sistemas; e, mesmo assim, uma aplica√ß√£o compilada em um sistema operacional (ambiente) n√£o pode ser executada em outro.

A linguagem Java rompeu este paradigma e passou a permitir que uma aplica√ß√£o desenvolvida em um ambiente - hardware + software (SO) - possa ser executada em outro sem necessidade de qualquer outro procedimento. A Sun Microsystems, ao tomar conhecimento desta ideia, deu total apoio ao seu desenvolvimento e criou um grupo com 13 membros, liderado por James Gosling, que passaram a trabalhar exclusivamente neste projeto. A equipe foi batizada de ‚ÄúGreen Team‚Äù e o grupo passou a trabalhar em um conjunto de escrit√≥rios fora das depend√™ncias f√≠sicas da Sun, e sem qualquer tipo de comunica√ß√£o com a matriz, durante 18 meses para a concretiza√ß√£o desta ideia.

Com a tecnologia Java, as aplica√ß√µes passaram a ser port√°veis de um sistema para o outro, sem nenhuma necessidade de altera√ß√£o. Por isso, afirmamos que a portabilidade √© uma das mais importantes caracter√≠sticas da linguagem Java.

Ainda naquela √©poca, o grupo j√° havia antecipado uma nova onda na computa√ß√£o, na converg√™ncia entre dispositivos controlados digitalmente e computadores. Hoje em dia, percebemos bem isso quando analisamos um smartphone, um dispositivo digital que possui in√∫meras fun√ß√µes de computadores; entre elas, podemos destacar a execu√ß√£o de aplicativos. Inicialmente, a linguagem foi batizada de **Oak**, pois o grupo tinha como vista da janela do escrit√≥rio *um carvalho*. Posteriormente, a linguagem foi rebatizada como **Java**, em fun√ß√£o do *gosto do grupo pelo tipo de caf√©*. Por isso, temos como √≠cone da linguagem uma x√≠cara de caf√© com sua fuma√ßa caracter√≠stica.

A linguagem √© muito poderosa para o desenvolvimento de aplica√ß√µes, seja para o desenvolvimento de aplica√ß√µes menos sofisticadas ou para uso em dispositivos menos complexos que computadores, conhecidos como dispositivos inteligentes, tais como cafeteiras, micro-ondas, geladeiras e uma gama de outros dispositivos que possam ser controlados por software. A linguagem ainda √© muito eficiente no desenvolvimento de sistemas de entretenimento dom√©stico, dando suporte a streaming de v√≠deo e televis√£o digital, que ainda n√£o era t√£o desenvolvida na √©poca.

A tecnologia Java permite ainda o desenvolvimento de todos os tipos de aplica√ß√µes, indo do mais simples controle de um eletrodom√©stico, passando por aplica√ß√µes dom√©sticas, comerciais, de automa√ß√£o, at√© o desenvolvimento de aplica√ß√µes mais complexas, com comunica√ß√£o de dados e aplica√ß√µes para supercomputadores.

A linguagem Java teve in√≠cio ao incorporar a tecnologia Java ao navegador de internet *Netscape navigator*, em sua vers√£o de 1995. A tecnologia ganhou a aceita√ß√£o do mercado e dos desenvolvedores, sendo uma das mais importantes linguagens de programa√ß√£o para o desenvolvimento de sistemas. S√£o dezenas de milh√µes de desenvolvedores Java no mundo e, atualmente, esta tecnologia √© encontrada em supercomputadores, servidores, desktops, notebooks, m√°quinas de cart√µes de cr√©dito e d√©bito, rob√¥s, autom√≥veis, jogos eletr√¥nicos, bem como uma gama de dispositivos digitais, redes e demais tecnologias de programa√ß√£o. A linguagem Java ainda √© a linguagem nativa para o desenvolvimento de aplica√ß√µes para o Android (sistema operacional para smartphones).

A tecnologia Java foi totalmente gratuita por muito tempo, mas recentemente a Oracle, que passou a deter os direitos da linguagem ap√≥s adquirir a Sun Microsystems, est√° licenciando o uso para empresas com custos. A empresa deve permitir o licenciamento gratuito somente para desenvolvedores avulsos que criam aplica√ß√µes pessoais sem custo ou para simples aprendizado.

## Principais caracter√≠sticas e vantagens da tecnologia Java
- Orientada a objetos, com uma grande diversidade de bibliotecas de classes dispon√≠vel;
- Independe de plataforma: write once, run everywhere ;
- Seguran√ßa - Mecanismos para sistemas livres de v√≠rus, pacotes para criptografia;
- Simplicidade;
- Sintaxe dos comandos b√°sicos segue o padr√£o do C;
- Sintaxe da parte OO bem mais simples que o C++;
- Internacionaliza√ß√£o;
- Unicode: padr√£o que permite manipular textos de qualquer sistema de escrita;
- Robustez;
- Tratamento de exce√ß√µes;
- JVM (Java Virtual Machine) impede que uma aplica√ß√£o mal comportada paralise o sistema;
- Distribu√≠da e multitarefa;
- Os programas podem utilizar recursos da rede com a mesma facilidade que acessam arquivos locais;
- Trabalha com diversos protocolos (TCP/IP, HTTP, FTP);
- Execu√ß√£o simult√¢nea de m√∫ltiplas threads;
- Gerenciamento de mem√≥ria;
- Mem√≥ria virtual gerenciada pela JVM (Java Virtual Machine);
- Garbage collection (limpeza de mem√≥ria);
- Desempenho;
- Mais r√°pida que linguagens de script, por√©m mais lenta que as linguagens compiladas puras;
- Hoje, os problemas de desempenho s√£o resolvidos com compila√ß√£o just-in-time.

# ‚òï Plataforma Java üöß
<div align="center"><img src="https://www.intexsoft.com/images/intexsoft/blog/JVM/jvm1.png"></div>

De forma geral, entendemos que plataforma (ambiente de execu√ß√£o) √© composta por hardware + software b√°sico (sistema operacional).

A plataforma Java √© definida apenas em software e possui dois componentes:

- **M√°quina Virtual Java** (JVM - Java Virtual Machine);
- **Conjunto de bibliotecas que disponibilizam classes comuns**.


## API Java
[![.JAR](https://img.shields.io/badge/-App.jar-000000?style=social&logo=Java&logoColor=brown)](#)
[![.JAR](https://img.shields.io/badge/-App.class-000000?style=social&logo=Java&logoColor=brown)](#)

<div align="center"><img src="https://user-images.githubusercontent.com/61624336/113073382-5e214b80-919f-11eb-8141-93ea67a402dc.png" height="477"></div>

"Diferentemente das linguagens convencionais, que s√£o compiladas para c√≥digo nativo, a linguagem Java √© compilada para "bytecode" (gerando o <code>.class</code> ou <code>.jar</code>), que √© executado por uma m√°quina virtual Java (JVM - Java Virtual Machine)."

<div align="center"><img src="https://user-images.githubusercontent.com/61624336/112760358-0b903580-8fcd-11eb-9e08-46f78186e835.png" height="170"><img src="https://user-images.githubusercontent.com/61624336/112760365-164aca80-8fcd-11eb-9d83-4b7ee0043b5f.jpg" height="170"></div>

O modelo inicial era interpretado. J√° o atual trocou a etapa do interpretador por uma 2¬™ compila√ß√£o (compilador JIT, isto √©, just-in-time).

A tecnologia Java √© composta por tr√™s plataformas:

<div align="center"><img src="https://cdn.worldvectorlogo.com/logos/jee-2.svg" height="177"></div><br \>

- **J2SE** ou **Java SE (Java Standard Edition)**: base da plataforma, inclui o ambiente de execu√ß√£o e as bibliotecas comuns;
- **J2EE** ou **Java EE (Java Enterprise Edition)**: vers√£o voltada para o desenvolvimento de aplica√ß√µes corporativas e aplica√ß√µes web;
- **J2ME** ou **Java ME (Java Micro Edition)**: vers√£o voltada para o desenvolvimento de aplica√ß√µes m√≥veis ou embarcadas.

## Ambiente de desenvolvimento
Existem os ambientes JDK e JRE para construir e executar uma aplica√ß√£o Java.

## Java Development Kit (JDK)
Cole√ß√£o de programas para, dentre outras tarefas, compilar e executar aplica√ß√µes Java. Este √© o kit necess√°rio para o desenvolvedor, pois cont√©m todo o suporte para a cria√ß√£o de aplica√ß√µes em Java.

Exemplo:
- Javac (compilador Java);
- Javadoc (utilit√°rio para documenta√ß√£o);
- Java;
- Outros.

## Java Runtime Environment (JRE)
Kit com todos os programas necess√°rios para executar aplica√ß√µes Java. Faz parte do JDK, mas pode ser instalado separadamente para execu√ß√£o em m√°quinas clientes, uma vez que o JDK √© voltado para os desenvolvedores. O JRE pode ser instalado separadamente e d√° suporte somente a execu√ß√£o de aplica√ß√µes ou jogos como o Minecraft, por isso √© a vers√£o mais indicada para instala√ß√£o nas m√°quinas clientes que apenas executar√£o aplica√ß√µes, n√£o sendo respons√°veis pelo seu desenvolvimento.

## Fases de um programa em linguagem Java
![img01](https://user-images.githubusercontent.com/61624336/112771689-6c3a6500-9003-11eb-8436-1bda07a25ea3.jpg)

O c√≥digo de um programa Java √© compilado apenas uma vez, gerando um c√≥digo intermedi√°rio, o **bytecode**, que pode ser executado quantas vezes forem necess√°rias em qualquer ambiente que possua uma m√°quina virtual Java (JVM) dispon√≠vel.

Inicialmente a tecnologia Java realizava uma interpreta√ß√£o completa do bytecode, mas atualmente o interpretador realiza uma compila√ß√£o **just-in-time** (compila o bytecode para o ambiente onde ocorrer√° a execu√ß√£o), permitindo aumentar o desempenho da aplica√ß√£o.

<div align="center"><img src="https://aprendafazer.net/wp-content/uploads/2019/10/NetBeans-1.png" height="170"></div>

Para o desenvolvimento de aplica√ß√µes em Java √© comum o uso de ferramentas IDEs (Integrated Development Environment), que facilitam a codifica√ß√£o e a realiza√ß√£o de testes, sendo as mais conhecidas:
  
- Eclipse;
- NetBeans;
- IntelliJ;
- BlueJ.

[![.JAR](https://img.shields.io/badge/-App.java-000000?style=social&logo=Java&logoColor=brown)](#)

Voc√™ pode usar qualquer tipo de ambiente, se preferir um editor de texto como um bloco de notas ou um VSCode voc√™ precisa usar a extens√£o **.java**.

<hr>

# ‚òï Ambiente de programa√ß√£o ‚ô®Ô∏è
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/9/98/Apache_NetBeans_Logo.svg" height="170">&nbsp;&nbsp;<img src="https://cdn.worldvectorlogo.com/logos/eclipse-11.svg" height="170"></div><br \>

Existem v√°rias ferramentas para o desenvolvimento de sistemas utilizando a linguagem Java, mas os desenvolvedores t√™m prefer√™ncia pelos IDEs **Netbeans** e **Eclipse**. Ambos s√£o gratuitos e podem ser adquiridos pela internet atrav√©s de download.

√â importante que voc√™ j√° tenha instalado o JDK antes de instalar o seu IDE escolhido (Netbeans ou Eclipse). Assista o v√≠deo: 

## NetBeans
<div align="center"><a href="https://netbeans.apache.org/download/index.html"><img src="https://upload.wikimedia.org/wikipedia/commons/9/98/Apache_NetBeans_Logo.svg" height="170" title="Click to install!"></a></div>

Existem dois arquivos diferentes: o primeiro, com o source, cont√©m os c√≥digos fonte no Netbeans e n√£o √© o ideal para trabalharmos o desenvolvimento. A vers√£o adequada para n√≥s √© a vers√£o bin, que cont√©m todos os c√≥digos j√° compilados e prontos para a execu√ß√£o e desenvolvimento de projetos e aplica√ß√µes Java.

## Eclipse
<div align="center"><a href="https://www.eclipse.org/downloads/"><img src="https://cdn.worldvectorlogo.com/logos/eclipse-11.svg" height="170" title="Click to install!"></a></div>

Voc√™ n√£o precisa instalar as duas, pois ambas s√£o concorrentes e desempenham as mesmas funcionalidades. A prefer√™ncia √© a crit√©rio do programador.

A linguagem Java possui uma base de constru√ß√£o semelhante √† linguagem C e, por isso, boa parte de sua estrutura e sintaxe se assemelha a ela. Desta forma, programadores com conhecimento nesta linguagem tem grande facilidade com a sintaxe da linguagem Java. Outra importante semelhan√ßa est√° nas estruturas de controle de fluxo, que s√£o constru√≠das da mesma forma em ambas as linguagens.

<blockquote>Cuidado com as diferen√ßas de vers√µes no sistema operacional: se instalar o Java para 64 bits, voc√™ dever√° usar um IDE (Netbeans ou Eclipse) de 64 bits. O mesmo para a vers√£o de 32 bits: tanto o Java quanto o IDE dever√£o ser para 32 bits.</blockquote>

## Criando o primeiro projeto com o NetBeans
![img02](https://user-images.githubusercontent.com/61624336/112783447-ba606000-9025-11eb-99c1-9849bac132dd.jpg)
![img03](https://user-images.githubusercontent.com/61624336/112783450-bc2a2380-9025-11eb-9ad8-b3425b12416e.jpg)
![img04](https://user-images.githubusercontent.com/61624336/112783457-bd5b5080-9025-11eb-9ed8-7834c9429c27.jpg)
![img05](https://user-images.githubusercontent.com/61624336/112783460-be8c7d80-9025-11eb-9d0e-38d8ce22f537.jpg)
![img06](https://user-images.githubusercontent.com/61624336/112783560-f7c4ed80-9025-11eb-9aa5-db63dc209059.jpg)

O projeto **Exemplo** foi criado e automaticamente teremos uma **classe inicial** para execu√ß√£o da aplica√ß√£o.

![img07](https://user-images.githubusercontent.com/61624336/112783806-89ccf600-9026-11eb-9a35-7d2d9b04774e.jpg)

O ambiente est√° pronto para digitarmos o c√≥digo da aplica√ß√£o: preencha o c√≥digo conforme o exemplo a seguir.

![img08](https://user-images.githubusercontent.com/61624336/112783867-ac5f0f00-9026-11eb-824b-76e8d7f981c5.jpg)

### C√≥digo completo

![img09](https://user-images.githubusercontent.com/61624336/112783960-dca6ad80-9026-11eb-8f34-d32ee5ec1380.jpg)

Ap√≥s o c√≥digo estar pronto e sem erros, podemos executar a aplica√ß√£o clicando sobre o ‚Äúarquivo da classe‚Äù com o bot√£o direito, e em seguida clicar sobre a op√ß√£o **Run file**.

![img10](https://user-images.githubusercontent.com/61624336/112784797-e7624200-9028-11eb-8739-7c214e90e4f0.jpg)

A aplica√ß√£o executar√° na parte inferior do Netbeans:

![img11](https://user-images.githubusercontent.com/61624336/112784856-03fe7a00-9029-11eb-93f7-7da23c1e5735.jpg)

## Acessando o Java pelo terminal
Crie um programa em java e execute os seguintes comandos para abri-lo.

![image](https://user-images.githubusercontent.com/61624336/113492455-d47ac200-94ad-11eb-99a2-946ea9250590.png)
![VirtualBox_Hadoop_ubuntu_SN_07_02_2017_03_37_06](https://user-images.githubusercontent.com/61624336/113488537-2d8a2c00-9495-11eb-9c21-876304e8d4cf.png)

```
javac app.java
java app
```
<hr>

<h1>‚òï Caracter√≠sticas da linguagem Java üîç</h1>

A linguagem **Java** tem boa parte de suas caracter√≠sticas herdadas da linguagem **C**. Muitos dos seus operadores, forma√ß√£o de identificadores, comandos de controle de fluxo e v√°rias outras caracter√≠sticas s√£o compartilhados entre estas duas linguagens.

Todas as instru√ß√µes da linguagem Java devem terminar por um s√≠mbolo de ponto e v√≠rgula ‚Äú<code>;</code>‚Äù. Voc√™ n√£o usar√° o ponto e v√≠rgula quando a instru√ß√£o for uma codifica√ß√£o que ir√° continuar com um bloco de comandos.

Vejamos um exemplo:

```java
System.out.println(‚ÄúMensagem do sistema‚Äù);
```

Os blocos de comandos em Java s√£o delimitados por <code>{</code> (abrir) e <code>}</code> (fechar) chaves, em que a instru√ß√£o anterior define que todos os comandos do bloco far√£o parte desta. Isso ir√° ocorrer em classes, m√©todos e instru√ß√µes de controle de fluxo. 

Exemplo:

```java
if(nota>10.0) {

System.out.println(‚ÄúNota inv√°lida‚Äù);

}
```

## Como usar a endenta√ß√£o?
Quando desenvolvemos um programa em qualquer linguagem, √© comum que utilizemos um conjunto de espa√ßos na frente das instru√ß√µes de forma a facilitar a visualiza√ß√£o de blocos. Sempre que iniciamos um bloco, devemos come√ßar na pr√≥xima linha com um deslocamento de pelo menos quatro espa√ßos em brando ou uma tabula√ß√£o (normalmente quatro espa√ßos). Isso permite que identifiquemos rapidamente que certo conjunto de instru√ß√µes faz parte de um conjunto que ser√° executado em bloco. 

Exemplo:

```java
import java.util.Scanner;

<b>public class Exemplo</b> {

// identa√ß√£o do bloco da classe Exemplo (a classe sempre possui o nome do arquivo, os dois andam bem alinhados!)

<b>public static void main(String[] args)</b> {

// identa√ß√£o do bloco do m√©todo main

// TODO Auto-generated method stub

Scanner sc = new Scanner(System.in);

double media, nota1, nota2;

System.out.println("Digite a nota 1:");

nota1 = Double.parseDouble(sc.nextLine());

System.out.println("Digite a nota 2:");

nota2 = Double.parseDouble(sc.nextLine());

media = (nota1 + nota2) /2.0;

System.out.println("A sua m√©dia √©:" + media);

sc.close();

} // encerramento da identa√ß√£o do bloco do m√©todo main

} // encerramento da identa√ß√£o da classe Exemplo
```

Em todas as linguagens de programa√ß√£o, devemos identificar vari√°veis, programas, fun√ß√µes, m√©todos, par√¢metros etc. O ato de nomear algo em uma linguagem de programa√ß√£o √© uma forma de identifica√ß√£o da linguagem. Em Java s√£o permitidos identificadores que comecem com letras (mai√∫sculas ou min√∫sculas), ou um s√≠mbolo de ‚Äú<code>$</code>‚Äù (d√≥lar) ou ‚Äú<code>_</code>‚Äù (underscore <code>/</code>underline). N√∫meros podem ser usados, mas n√£o para iniciar um identificador.

**Java** √© uma linguagem de programa√ß√£o sens√≠vel √† caixa (alta ou baixa ou **case sensitive**). Desta forma, a linguagem faz distin√ß√£o entre letras mai√∫sculas e min√∫sculas. Mas isso n√£o quer dizer que podemos utilizar qualquer nome como um identificador, pois existem algumas palavras reservadas que n√£o podem ser utilizadas para tal. 

Exemplos de identificadores v√°lidos em Java:
- identificador
- nomeCompleto
- NomeCompleto
- nota1
- _sys_path
- $user

Observe que os exemplos 2 e 3 possuem a mesma grafia, mas, como existe mudan√ßa entre caixa alta e baixa, para a linguagem Java s√£o dois diferentes identificadores. 

Palavras reservadas da linguagem Java (n√£o podem ser usadas como identificadores); dentre elas podemos destacar:

- abstract
- boolean
- break
- byte
- case
- catch
- char
- class
- continue
- do
- double
- else
- extends
- false
- final
- finally
- float
- for
- implements
- import
- instanceof
- int
- interface
- long
- native
- new
- null
- private
- protected
- public
- return
- short
- static
- super
- switch
- synchronized
- tdrow
- throws
- transient
- true
- try
- void
- volatile
- while

<blockquote><b>OBS:</b> Todas as palavras reservadas come√ßam por letras min√∫sculas e s√£o palavras do idioma ingl√™s.</blockquote>

## Coment√°rios em Java
O uso de coment√°rios em Java √© semelhante ao usado na linguagem C, mas apenas dois destes tipos s√£o iguais nas duas linguagens, sendo o terceiro tipo somente disponibilizado na linguagem Java.

Vejamos:

### <code>//</code> coment√°rio de uma linha  

Quando usamos duas barras em uma linha de c√≥digo, todo o seu conte√∫do, ap√≥s as duas barras, √© desconsiderado pelo compilador, o que quer dizer que podemos escrever qualquer conte√∫do que o mesmo n√£o ser√° compilado. √â muito usado para deixar informa√ß√µes e avisos do programador no c√≥digo.

```java
// TODO Auto-generated method stub</pre>
```

### <code>/**/</code> coment√°rio de duas ou mais linhas (bloco)

Ao usarmos o coment√°rio de bloco, podemos comentar n√£o apenas um trecho de uma linha, mas todo um conjunto de linhas. √â utilizado quando temos longos trechos de textos com avisos e informa√ß√µes, ou para a depura√ß√£o do c√≥digo. Para a depura√ß√£o do c√≥digo, podemos comentar um conjunto de linhas para realizar um conjunto de testes. Neste caso, podemos comentar um conjunto de instru√ß√µes ou porque estas instru√ß√µes est√£o com problemas e queremos verificar as demais. Ou, ao contr√°rio, onde temos um conjunto de instru√ß√µes j√° testadas e corretas e queremos apenas testar as demais. Seja como for, o uso do coment√°rio de bloco √© muito usual e comum entre os programadores.

### <code>/***/</code> coment√°rio de documenta√ß√£o

O coment√°rio de documenta√ß√£o se difere do coment√°rio de bloco por possuir um asterisco a mais no in√≠cio, mas ambos encerram da mesma forma. Existe uma ferramenta na linguagem Java respons√°vel por extrair de um projeto (com v√°rias classes) todos os coment√°rios de documenta√ß√£o e montar um documento com todo este conte√∫do.  

Neste caso, usamos este tipo de coment√°rio apenas para descrever avisos e informa√ß√µes das classes, de forma a realizar a documenta√ß√£o do sistema ainda durante sua fase de cria√ß√£o. Isto permite que o desenvolvedor descreva todo a documenta√ß√£o no pr√≥prio projeto, facilitando a descri√ß√£o e a manuten√ß√£o do sistema. Assim, ao terminar um projeto ou realizar algum tipo de modifica√ß√£o, basta gerar novamente a documenta√ß√£o do sistema que tudo estar√° atualizado.

## Tipos de dados 
A linguagem Java possui nove tipos de dados b√°sicos, sendo oito deles primitivos e um tipo especial.

## Primitivos (armazenam apenas valores)

### Tipo l√≥gico (boolean)
O tipo l√≥gico s√≥ permite dois estados, verdadeiro (<code>true</code>) ou falso (<code>false</code>); em Java ainda √© permitido o uso de <code>on</code> e <code>off</code>, ou <code>yes</code> e <code>no</code>. 

Exemplo:

<pre>boolean status = true;</pre>

### Tipo caractere (char)
O tipo char permite que seja armazenado na mem√≥ria apenas um caractere e se difere do texto (String) por ser definido entre ‚Äòe‚Äô. Quando usamos aspas simples ou dupla determinamos apenas um caractere.

Exemplo:

<pre>char letra = ‚ÄòA‚Äô;</pre>

### Armazenamento de caracteres de controle
Tamb√©m √© poss√≠vel armazenar caracteres de controle:

<table>
  <tr>
    <td><b>Caractere Especial</b></td>
    <td><b>Representa√ß√£o</b></td>
  </tr>
  <tr>
     <td><code>‚Äô\n‚Äô</code></td>
    <td>nova linha.</td>
  </tr>
   <tr>
     <td><code>‚Äô\r‚Äô</code></td>
    <td>enter.</td>
  </tr>
  <tr>
     <td><code>‚Äô\u????‚Äô</code></td>
    <td>especifica um caractere Unicode o qual √© representado na forma Hexadecimal.</td>
  </tr>
    <tr>
     <td><code>‚Äô\t‚Äô</code></td>
    <td>tabula√ß√£o.</td>
  </tr>
  <tr>
    <td><code>‚Äô\\‚Äô</code></td>
    <td>representa um caractere <code>\</code> (barra invertida).</td>
  </tr>
    <tr>
    <td><code>‚Äô\‚Äù ‚Äô</code></td>
      <td>representa um caractere <code>‚Äú</code> (aspas)</td>
  </tr>
</table>

<blockquote><b>OBS:</b> A barra invertida na frente indica que √© um caractere especial.</blockquote>

### Tipos inteiros (byte, short, int e long)
S√£o quatro diferentes tipos de inteiros, que se diferenciam pela quantidade de bits que cada um ocupa em mem√≥ria para armazenar um valor. Isto faz com que, quanto menor a quantidade de bits, maior seja a limita√ß√£o do valor a ser armazenado. Entretanto, em ocasi√µes onde a mem√≥ria √© pouca, devemos trabalhar muito bem com estas diferen√ßas para reduzir o espa√ßo de mem√≥ria necess√°rio. O uso mais comum √© do <code>int</code>, mas, para n√∫meros muito grandes ou muito pequenos, devemos usar o <code>long</code>. J√° para economizar mem√≥ria podemos usar <code>byte</code> ou <code>short</code>, de acordo com o valor que ser√° armazenado.

<table>
  <tr>
    <td><b>Tipo de dado</b></td>
    <td><b>Quantidade de bits</b></td>
    <td><b>Quantidade de Bytes</b></td>
    <td><b>Escopo (valores que podem ser armazenados)</b></td>
  </tr>
   <tr>
    <td><code>byte</code></td>
    <td>8</td>
    <td>1</td>
    <td>-2‚Å∑ . . . . 2‚Å∑ - 1</td>
  </tr>
  <tr>
    <td><code>short</code></td>
    <td>16</td>
    <td>4</td>
    <td>-2¬≥¬π . . . . 2¬≥¬π - 1</td>
  <tr>
  <tr>
    <td><code>long</code></td>
    <td>64</td>
    <td>8</td>
    <td>-2‚Å∂¬≥ . . . . 2‚Å∂¬≥ - 1</td>
</table>    

### Tipos reais (float e double)
S√£o dois diferentes tipos de valores reais, sendo um de precis√£o simples (<code>float</code>), que ocupa menos espa√ßo de mem√≥ria, e o de dupla precis√£o, que ocupa mais mem√≥ria. Quanto maior o n√∫mero de bits para armazenar um valor real, maior ser√° a precis√£o deste n√∫mero dentro do sistema. O uso do <code>float</code> √© comum quando necessitamos economizar espa√ßo de mem√≥ria. Em Java, todo tipo de dado num√©rico √© convertido para <code>double</code> automaticamente por coer√ß√£o (for√ßa a convers√£o de tipo). Por isso, √© mais indicado, quando n√£o houver falta de espa√ßo de mem√≥ria, a utiliza√ß√£o de <code>double</code> para armazenamento de valores reais.

<table>
  <tr>
    <td><b>Tipo de dado</b></td>
    <td><b>Quantidade de bits</b></td>
    <td><b>Quantidade de Bytes</b></td>
  </tr>
  <tr>
    <td><code>float</code></td>
    <td>32</td>
    <td>4</td>
  </tr>
   <tr>
    <td><code>double</code></td>
    <td>64</td>
    <td>8</td>
  </tr>
</table>    

## Tipo especial
### Tipo texto (String)
O tipo texto (<code>String</code>) n√£o √© um tipo primitivo, mas um tipo especial. Na verdade, o tipo String √© uma classe e por isso come√ßa com letra mai√∫scula, ao contr√°rio dos tipos primitivos, que sempre come√ßam por min√∫sculas. Este tipo de dado armazena um conjunto de caracteres, formando palavras ou frases de tamanhos variados. Como classe, veremos mais tarde que elementos do tipo String possuem m√©todos que podem realizar a√ß√µes espec√≠ficas sobre o seu conte√∫do. 

Exemplo:

<pre>String nome = ‚ÄúJo√£o da Silva‚Äù;</pre>

## ‚òï Constantes e vari√°veis üì•
Vari√°veis e constantes em Java devem **obrigatoriamente possuir um tipo**. Isso ocorre porque **Java √© uma linguagem de programa√ß√£o fortemente tipada**.

### Linguagens de programa√ß√£o fortemente tipadas
Obrigam que todas as vari√°veis e constantes sejam definidas por um tipo de dado.

### Linguagens de programa√ß√£o fracamente tipadas
Permitem que vari√°veis sejam usadas a qualquer momento, sem a necessidade de terem um tipo predefinido. Isso quer dizer que o tipo de dado pode variar em diferentes partes do programa.

**Vari√°veis** s√£o declaradas por meio de *um tipo* e *um identificador*, sem que sejam necess√°rias outras informa√ß√µes. A boa pr√°tica em programa√ß√£o Java determina que todas as vari√°veis comecem por letras min√∫sculas e, somente se tiver mais de uma palavra, o inicial da segunda palavra em diante dever√° come√ßar por letras mai√∫sculas. 

Exemplos:

<pre>
int c;
double nota1 = 0; // indica que a vari√°vel ser√° inicializada com 0 (zero)
String nomeCompleto;
</pre>

A defini√ß√£o de constantes precisam do modificador final, que indica que, uma vez que ocorreu uma atribui√ß√£o a vari√°vel, seu conte√∫do n√£o poder√° ser mudado. Em Java, constantes podem ser criadas em nomes em min√∫sculas ou mai√∫sculas, mas a boa pr√°tica de programa√ß√£o determina que sua identifica√ß√£o deve ser toda em mai√∫sculas. 

Exemplos:

<pre>
final int IDADEMINIMA = 15;
final double VALORDOLAR = 3.96;
final NOMEEMPRESA = ‚ÄúSuper Empreendimentos‚Äù;
</pre>

##  Operadores e express√µes +
### Operadores aritm√©ticos X + -

<table>
  <tr>
    <td><b>Operador</b></td>
    <td><b>Descri√ß√£o</b></td>
  </tr>
    <tr>
    <td><code>=</code></td>
    <td>Atribui√ß√£o</td>
  </tr>
  <tr>
    <td><code>+</code></td>
    <td>Soma</td>
  </tr>
  <tr>
    <td><code>-</code></td>
    <td>Subtra√ß√£o</td>
  </tr>
  <tr>
    <td><code>*</code></td>
    <td>Multiplica√ß√£o</td>
  </tr>
  <tr>
    <td><code>/</code></td>
    <td>Divis√£o</td>
  </tr>
  <tr>
    <td><code>%</code></td>
    <td>Resto da divis√£o</td>
  </tr>
</table>

<blockquote><b>OBS:</b> Java sempre realizar√° a opera√ß√£o inteira quando os operandos forem inteiros, e a opera√ß√£o real ocorrer√° caso um ou mais operando seja real.</blockquote>

Exemplos:

<pre>int v = 7 / 2; // o valor atribu√≠do ser√° 3 e n√£o 3.5, porque ambos os operandos s√£o inteiros

double v = 7.0 / 2; // o valor atribu√≠do ser√° 3.5, porque o primeiro operando √© real.</pre>

A mesma l√≥gica serve para vari√°veis:

<pre>int a, b=7, c=2;

a = b / c; // ser√° armazenado 3 em a.

double a, b=7.0, c=2.0;

a = b / c; // ser√° armazenado 3.5 em a.</pre>

Podemos alterar o tipo de um operando em uma express√£o utilizando o **cast**, que nada mais √© do que informar que o valor armazenado na vari√°vel ter√° o seu valor em fun√ß√£o do tipo alterado. 

Exemplo:

```java
int b=7, c=2;

double a=0;

a = (double) b / c; // o valor de b ser√° convertido para double antes da opera√ß√£o

// e isso far√° com que o primeiro operando seja real e desta

// forma a opera√ß√£o ser√° real, armazenado 3.5 em a.
```

## Operadores aritm√©ticos 
<pre> +=   -=   *=   /=   %= </pre>

Exemplo:

```java
int alturaParede = 2.85; // declara√ß√£o da vari√°vel alturaParede

alturaParede += 0.15; // a vari√°vel alturaParede ter√° o valor

// acrescido (somado) em 0.15, sendo

// equivalente a:

// alturaParede = alturaParede + 0.15;
```

Desta forma, n√£o precisamos colocar o nome da vari√°vel duas vezes.

### ‚òï Operadores de Incremento e decremento
Em Java temos os operadores de incremento <code>++</code> e de decremento <code>--</code>, que sempre adicionam uma unidade (<code>++</code>) ou subtraem uma unidade (<code>--</code>). Eles podem ser ainda divididos em **pr√©-incremento** e **p√≥s-incremento**, e **pr√©-decremento** e **p√≥s-decremento**. 

O **pr√©-incremento** determina que primeiro seja realizada a opera√ß√£o de incremento e depois √© realizada a opera√ß√£o de atribui√ß√£o. 

Exemplo:

```java
int a = 20, b=0;

b = ++a; // primeiro a vari√°vel a ser√° incrementada de uma unidade, valendo 21,

// depois b receber√° o valor de a e assim, tamb√©m valer√° 21.
```

O **p√≥s-incremento** determina que antes seja realizada a atribui√ß√£o para s√≥ ent√£o ser realizada a opera√ß√£o de incremento. 

Exemplo:
<pre>int a = 20, b=0;

b = a++; // primeiro b receber√° o valor de a, que √© 20 (antes do incremento),

// depois a ser√° incrementado e assim, o valor de a ser√° 21 e o de b ser√° 20.</pre>

O **pr√©-decremento** determina que primeiro seja realizada a opera√ß√£o de decremento e depois √© realizada a opera√ß√£o de atribui√ß√£o.

Exemplo:

<pre>int a = 20, b=0;

b = --a; // primeiro a vari√°vel a ser√° decrementada de uma unidade, valendo 19,

// depois b receber√° o valor de a e assim, tamb√©m valer√° 19.</pre>

O **p√≥s-decremento** determina que antes seja realizada a atribui√ß√£o para s√≥ ent√£o ser realizada a opera√ß√£o de decremento. 

Exemplo:

<pre>
int a = 20, b=0;

b = a--; // primeiro b receber√° o valor de a, que √© 20 (antes do incremento),

// depois a ser√° decrementado e, assim, o valor de a ser√° 19 e o de b ser√° 20.
</pre>

## Operadores de Relacionais (usados para definir condi√ß√µes)

<table>
  <tr>
    <td><b>Operador</b></td>
    <td><b>Descri√ß√£o</b></td>
  </tr>
    <tr>
    <td><code>==</code></td>
    <td>Igualdade/ Compara√ß√£o</td>
  </tr>
  <tr>
    <td><code>!=</code></td>
    <td>Nega√ß√£o/ Diferente</td>
  </tr>
  <tr>
    <td><code>&gt;</code></td>
    <td>Maior que</td>
  </tr>
  <tr>
    <td><code>&lt;</code></td>
    <td>Menor que</td>
  </tr>
  <tr>
    <td><code>&gt;=</code></td>
    <td>Maior ou igual a</td>
  </tr>
    <tr>
    <td><code>&lt;=</code></td>
    <td>Menor ou igual a</td>
  </tr>
</table>

Exemplos:

<pre>1) if(a > b) { ... }

2) while (a <=100) { ... }

3) for (int c =0; c<50; c++) { ... }</pre>

## Operadores de em Express√µes L√≥gicas

<table>
   <tr>
    <td><b>Operador</b></td>
     <td><b>Descri√ß√£o</b></td>
  </tr>
  <tr>
    <td><code>!</code></td>
     <td>N√ÉO l√≥gico</td>
  </tr>
  <tr>
    <td><code>&&</code></td>
    <td>E l√≥gico</td>
  </tr>
  <tr>
    <td><code>||</code></td>
    <td>OU l√≥gico</td>
  </tr>
</table>

S√£o os determinantes das tabelas-verdade. 

Ordem de preced√™ncia: **!, &&, ||** 

Exemplos:

<pre>if(a > b && c < d) { ... }

while (a <=100 || b == 10) { ... }

if( !a == 15 && b >= 10) { ... }

if( !a == 15 || c > d && b >= 10) { ... }</pre>

Pela ordem de preced√™ncia: if( (!a == 15) || (c > d && b >= 10)) 

Primeiro ser√° executada a nega√ß√£o (!); depois o e l√≥gico (&&) e por √∫ltimo o ou l√≥gico (||).

## Operadores de bits

<table>
  <tr>
    <td><b>Operador</b></td>
    <td><b>Descri√ß√£o</b></td>
  </tr>
  <tr>
    <td><code>&</code></td>
    <td>E entre bits</td>
  </tr>
  <tr>
    <td><code>^</code></td>
    <td>OU EXCLUSIVO entre bits</td>
  </tr>
   <tr>
    <td><code>|</code></td>
    <td>OU entre bits</td>
  </tr>
</table>

Ordem de preced√™ncia: 
<ol>
  <li><code>&</code></li>
  <li><code>^</code></li>
  <li><code>|</code></li>
</ol>

# ‚òï Comandos de controle de fluxo ‚úîÔ∏è‚ùåüîÅ
Servem para determinar se as condi√ß√µes s√£o verdadeiras ou controlar uma determinada ordem l√≥gica de eventos para o c√≥digo.

## ‚òï Estruturas Condicionais ‚úîÔ∏è‚ùå 

<h4 align="center">Primeira estrutura</h4>

<pre>Se (if):

if (condi√ß√£o) {

// instru√ß√µes;

}

// A cl√°usula else √© opcional.</pre>

<h4 align="center">Segunda estrutura</h4>

<pre>if ... else,

if (condi√ß√£o) {

// instru√ß√µes;

}

else {

// instru√ß√µes;

}</pre>

<h4 align="center">Terceira estrutura</h4>

<pre>if ... else if ... else,

if (condi√ß√£o1) {

instru√ß√µes;

}

else if (condi√ß√£o2) {

instru√ß√µes;

}

else if (condi√ß√£o3) {

instru√ß√µes;

}

else {

instru√ß√µes;

}</pre>

<blockquote>A cl√°usula if deve ocorrer apenas uma vez; As cl√°usulas else if podem ocorrer: nenhuma, uma ou v√°rias vezes; A cl√°usula else s√≥ pode ocorrer uma √∫nica vez.</blockquote>

<h4 align="center">Quarta estrutura</h4>

<code>switch ‚Ä¶ case</code>

Estruturas de decis√£o caracterizadas pela possibilidade de uma vari√°vel possuir v√°rios valores diferentes em uma determinada situa√ß√£o.  

Uma √∫nica estrutura <code>switch</code> pode analisar v√°rios diferentes valores para a vari√°vel de controle. A vari√°vel de controle em Java pode ser do tipo: <code>inteiro</code>, <code>caractere</code>, ou <code>String</code>. 

A cl√°usula <code>case</code> pode ocorrer de uma a v√°rias vezes, e a cl√°usula <code>default</code> √© opcional.

## ‚òï Estruturas de Repeti√ß√£o üîÅ
### for
**Estrutura de repeti√ß√£o** (La√ßos de repeti√ß√£o ou Loop) controlada por uma ou mais vari√°veis contadoras e caracterizada pela exist√™ncia de tr√™s par√¢metros, sendo todos eles opcionais:

**1** - Inicializa√ß√£o da(s) vari√°vel(is) de controle

**2** - Condi√ß√£o sobre a(s) vari√°vel(is) de controle para parada das itera√ß√µes

**3** - Passo da(s) vari√°vel(is) de controle a cada itera√ß√£o

<pre>for((1)inicializa√ß√£o; (2)condi√ß√£o de controle; (3)passo) {

// instru√ß√µes

}</pre>

Exemplo:

### 1) Repeti√ß√£o controlada por uma vari√°vel:

<pre>for (int c=1; c<=limite; i++) {

instru√ß√µes;

}</pre>

### 2) Repeti√ß√£o controlada por duas vari√°veis:

<pre>for (a=1, b=2; a*b&lt;limite; a++, b+=2) {

instru√ß√µes;

}</pre>

### 3) Repeti√ß√£o sem fim

<pre>for ( ; ; ) {

instru√ß√µes;

}</pre>

### while
Esta estrutura realiza a repeti√ß√£o de um conjunto de instru√ß√µes enquanto a condi√ß√£o determinada for verdadeira; caso a condi√ß√£o seja falsa no primeiro teste, nenhuma instru√ß√£o ser√° executada.

<pre>// realiza o teste da condi√ß√£o no in√≠cio da estrutura

while (condi√ß√£o) {

instru√ß√µes;

}</pre>

### do...while
Esta estrutura de repeti√ß√£o √© semelhante √† anterior, mas com o diferencial de que as condi√ß√µes devem ser verificadas apenas no final da estrutura, obrigando que as instru√ß√µes sejam sempre executadas pelo menos uma vez.

<pre>// Teste de condi√ß√£o no final

do

{

instru√ß√µes;

} while (condi√ß√£o);</pre>

## ‚òï Entrada e Sa√≠da de dados üì•üì§
### üì• Entrada de dados üì•
Em Java temos muitas formas de entrada de dados, inclusive de forma gr√°fica. Inicialmente trabalharemos com a *classe* <code>Scanner</code>, respons√°vel pela entrada de dados em formato texto, com perguntas diretas ao usu√°rio e a inclus√£o da resposta em vari√°veis do programa. 

Para realizarmos esta tarefa, **√© necess√°rio que seja criado um objeto da classe Scanner**. 

Para isso, devemos **importar** a *classe* <code>Scanner</code> antes do in√≠cio da programa√ß√£o da classe:

<pre>import java.util.Scanner;</pre>

Depois √© necess√°rio criar o **objeto** para realizar as entradas de dados:

<pre>public class <b>EntradaDados</b> {

public static void main (String[] args) {

Scanner entrada = new Scanner(System.in);

}

}</pre>

Existem v√°rios m√©todos associados a classe **Scanner** para a entrada de dados, mas para evitarmos problemas futuros podemos usar sempre a entrada de dados de texto <code>(nextLine())</code> e converter o texto para o tipo desejado.

Exemplo:

### 1) Para entrada de texto (String):

<pre>String nome;

Nome = entrada.nextLine(); // n√£o precisa de convers√£o, apenas da entrada.</pre>

### 2) Para entrada de valor real:

<pre>double nota1;

nota1=Double.<b>parseDouble</b>(entrada.nextLine());

// a entrada de dados em texto precisa de convers√£o para double.</pre>

### 3) Para entrada de valor inteiro:

<pre>int idade;

idade = Integer.<b>parseInt</b>(entrada.nextLine());

// a entrada de dados em texto precisa de convers√£o para int.</pre>

√â aconselh√°vel evitar o uso de m√©todos como:

- entrada.nextDouble();
- entrada.nextFloat();
- entrada.nextInt();

Estes m√©todos, quando usados em conjunto, podem fazer com que a aplica√ß√£o pule alguma entrada de dados, sendo necess√°rio que seja realizada uma ‚Äúlimpeza de buffer‚Äù. Este tipo de problema pode ser contornado ao usar sempre o m√©todo ‚ÄúnextLine()‚Äù e a convers√£o de tipos.

## üì§ Sa√≠da de dados üì§
A sa√≠da de dados em modo texto pode ser realizada pela *classe* <code>System</code>, e o m√©todo <code>out.print</code> (n√£o pula linha), <code>out.println</code> (pula linha) ou outros m√©todos:

### 1) Apenas uma mensagem:

<pre>System.out.println("Entre com a Nota A1.........: ");</pre>

### 2) Mensagem e conte√∫do de vari√°veis:

<pre>System.out.println(" Nome: " + nome + " Idade: " + idade + " Nota 1: " + nota1);</pre>

A seguir temos o exemplo completo de um programa que recebe duas notas e apresenta a m√©dia.

<pre>public class <b>Exemplo</b> {

public static void main(String[] args) {

// TODO Auto-generated method stub

Scanner sc = new Scanner(System.in);

double media, nota1, nota2;

System.out.println("Digite a nota 1:");

nota1 = Double.parseDouble(sc.nextLine());

System.out.println("Digite a nota 2:");

nota2 = Double.parseDouble(sc.nextLine());

media = (nota1 + nota2) /2.0;

System.out.println("A sua m√©dia √©:" + media);

sc.close();

}

}</pre>

## Convers√£o de tipos
A convers√£o de tipos em Java pode ser feita por cast ou com o uso de convers√£o por classes. Ambos j√° foram vistos em exemplos anteriores:

### 1) Por cast:
Usado para converter valores de um tipo para outro; com cast basta indicar o tipo que voc√™ quer que a vari√°vel, ou valor, seja convertida, colocando o tipo desejado entre par√™nteses:

### 2) Por uso de classes para convers√£o de textos em valores

<pre>double nota1 = Double.parseDouble(‚Äú7.8‚Äù);

int idade = Integer.parseInt(‚Äú34‚Äù);

float valor = Float.parseFloat(‚Äú2.15‚Äù);

long valor2 = Long.parseLong(‚Äú3456789‚Äù);

Pode-se usar ainda:

Byte.parseByte() / Short.parseShort()</pre>

## ‚ô®Ô∏è A boa pr√°tica em programa√ß√£o Java (BP) ‚ô®Ô∏è
A boa pr√°tica em programa√ß√£o Java leva em conta um conjunto de regras que facilitam o desenvolvimento de aplica√ß√µes e melhoram bastante o trabalho em conjunto realizado por equipes. Ao seguir estas regras, projetos podem ser desenvolvidos em paralelo por diferentes programadores, sem que seja necess√°rio que cada componente precise esperar que outros terminem suas tarefas. Estas regras foram utilizadas na constru√ß√£o da linguagem permitindo que n√£o seja necess√°rio decorar as sintaxes de instru√ß√µes Java. N√£o s√£o obrigat√≥rias, mas permitem a codifica√ß√£o melhor de nossas aplica√ß√µes.

### Regras:
1) Vari√°veis auxiliares, atributos, m√©todos e objetos devem ser identificados iniciando por letras min√∫sculas. Quando houver mais de uma palavra, deve-se come√ßar cada nova palavra com uma letra mai√∫scula. 

Exemplos:

<pre>int idade;

int maiorIdade;

String nome;

String nomeCompleto;</pre>

2) Constantes devem ser identificadas por letras mai√∫sculas em todo o seu nome; mesmo quando temos mais de uma palavra, todo o identificador deve ficar em mai√∫sculas. 

Exemplos:

<pre>final int idade;

final int maiorIdade;

final String nome;

final String nomeCompleto;</pre>

3) Classes e interfaces (tipo especial de classe) devem iniciar por letras mai√∫sculas. Quando houver mais de uma palavra, deve-se come√ßar cada nova palavra com uma letra mai√∫scula. 

Exemplos:

<pre>public class Carro { ... }

public class Carro Hibrido { ... }

public interface Basico { ... }

public interface MetodosBasicos { ... }</pre>
<hr>

<h1 align="center">Cap 03: ‚òï Classes e objetos ‚öΩ</h1>

Vamos aprender o paradigma de programa√ß√£o orientada a objetos (Poo).

**Link para apoio:** https://github.com/IsaacAlves7/programming-logic

## ‚öΩ Programa√ß√£o orientada a objetos ‚öΩ
A **programa√ß√£o orientada a objetos (POO)** tem como principal conceito representar, em um sistema computacional, um **objeto da vida real**.

Esta representa√ß√£o deve descrever o objeto quanto √†s suas caracter√≠sticas e a√ß√µes que poder√° realizar dentro do sistema.

N√£o devemos nos preocupar com todas as caracter√≠sticas presentes no objeto, mas com aquelas que ser√£o necess√°rias ao sistema (requisitos).

Exemplo: 

<blockquote>Por exemplo, a placa de um autom√≥vel √© importante para um sistema de estacionamento, assim como a hora de chegada e sa√≠da.

Em alguns casos, o fabricante, modelo e a cor do autom√≥vel poder√£o ser importantes, mas dificilmente iremos cadastrar o n√∫mero do chassi do mesmo. Como o n√∫mero do chassi n√£o √© facilmente visto e seu cadastramento dependeria da documenta√ß√£o do autom√≥vel ou de uma an√°lise para a identifica√ß√£o, que seria dif√≠cil, uma vez que √© um identificador com muitas letras e n√∫meros, acabaria por gerar filas e insatisfa√ß√£o dos clientes.

Entretanto, para o sistema de cadastramento do DETRAN, por exemplo, o n√∫mero do chassi √© uma das informa√ß√µes mais importantes. Dessa forma, identificarmos a placa √© importante como descritor do autom√≥vel para o sistema de estacionamento, j√° o chassi n√£o.</blockquote>

Por isso, devemos analisar cada objeto separadamente e quais s√£o as caracter√≠sticas importantes para o sistema em que o objeto ser√° utilizado. Como outro exemplo, podemos notar que a matr√≠cula, nome e CR de um aluno s√£o importantes para o sistema acad√™mico, mas o time para o qual o aluno torce ou sua religi√£o n√£o s√£o. Por isso, os descritores time e religi√£o n√£o s√£o importantes para o objeto Aluno em um sistema acad√™mico.

## üè´ Classes üè´
As **classes** Java s√£o respons√°veis pelo **conjunto de c√≥digos para a cria√ß√£o de objetos e aplica√ß√µes**. Uma classe Java deve descrever as *caracter√≠sticas e a√ß√µes* que o objeto possui ao ser representado em um sistema computacional, levando em considera√ß√£o as caracteristicas (atributos) e as a√ß√µes (m√©todos) juntamente ou n√£o com seus argumentos (par√¢metros).

## üßë Atributos üßë
**Atributo** √© conceitualmente um descritor do objeto e deve representar uma **caracter√≠stica**,  dele. O **conjunto de atributos** do objeto deve representar todas as *caracter√≠sticas importantes* do objeto para o sistema.

Exemplo:

<pre>String matricula; // atributo para armazenamento da matr√≠cula

String nome; // atributo para armazenamento do nome

double cr; // atributo para armazenamento do cr</pre>

## üßë‚Äçüè´ M√©todos üßë‚Äçüè´

**M√©todo** √© uma **a√ß√£o**, um conjunto de instru√ß√µes a serem executadas por um objeto para realizar uma determinada tarefa.

O **conjunto de m√©todos** de um objeto deve descrever **todas as a√ß√µes (tarefas ou fun√ß√µes)** que o objeto poder√° realizar dentro do sistema.

Exemplo:

<pre>public int soma(int n1, int n2){

int soma;

soma = n1 + n2;

return soma;

}

public void imprimeAumento(double salario, int percentual){

double aumento;

aumento = salario + salario * percentual / 100.0;

System.out.println("O sal√°rio com aumento √©: " + aumento);

}</pre>

## ‚öΩ Objetos ‚öΩ
A classe modela o **objeto** de acordo com as necessidades do sistema para a sua descri√ß√£o e suas a√ß√µes. A partir de uma mesma classe, v√°rios objetos diferentes, mas com caracter√≠sticas semelhantes, podem ser criados em um mesmo sistema ou em diferentes sistemas.

Se consideramos a classe Aluno, podemos criar a partir desta classe dezenas, centenas ou mesmo milhares de objetos Alunos com caracter√≠sticas semelhantes, tais como matr√≠cula, nome e CR, mas com propriedades (valores pr√≥prios nos atributos de cada objeto) diferentes.

Os *objetos* **s√≥ existem durante a execu√ß√£o do sistema**, pois estes s√≥ existir√£o como refer√™ncia na mem√≥ria do computador neste momento. Dizemos tamb√©m que os objetos s√≥ existem ‚Äúem tempo de execu√ß√£o‚Äù, uma vez que o sistema ao ser encerrado ter√° toda a sua mem√≥ria apagada. Consequentemente, todas as suas vari√°veis e objetos n√£o existir√£o mais.

### Exemplo: Aluno.java (objeto)

![print](https://user-images.githubusercontent.com/61624336/119859616-edbb5000-beeb-11eb-833d-c0b2e0cb77ba.png)

## ‚òï Aplica√ß√µes Java üî¢

**Aplica√ß√µes em Java** s√£o classes especiais que possuem um m√©todo <code>main()</code>. O m√©todo *main* **√© respons√°vel por criar os objetos e realizar a combina√ß√£o de diferentes classes para atender √†s necessidades de um sistema**.

Em cada sistema, temos **apenas uma aplica√ß√£o**, que ser√° **respons√°vel pela l√≥gica de cria√ß√£o e uso das classes**. A comunica√ß√£o entre os objetos ocorre por meio de **trocas de mensagens**, que s√£o **expressas com o uso de m√©todos**. Uma aplica√ß√£o, ent√£o, cria objetos a partir de uma ou mais classes e usa os m√©todos dos objetos para realizar as a√ß√µes que atender√£o √†s necessidades dos usu√°rios.

### Exemplo: AppAluno.java (aplica√ß√£o)

![print](https://user-images.githubusercontent.com/61624336/119884711-54019c00-bf07-11eb-9658-c7af50e520e2.png)

### Notas:

1. Cada **classe p√∫blica (public) deve ser criada em um arquivo pr√≥prio** e o **nome da classe deve ser o mesmo do arquivo**. Ou seja, a classe Aluno deve ser criada no **arquivo** <code>Aluno.java</code> e a **classe da aplica√ß√£o** "AppAluno" deve ser criada no arquivo <code>AppAluno.java</code>. No projeto, seja no Eclipse ou no Netbeans, dever√£o ser criadas duas classes, uma para o **Aluno** e outra para a **aplica√ß√£o**;

2. Foi criada apenas uma classe **Aluno**, mas a partir dela poderemos criar quantos objetos quisermos;

3. Na aplica√ß√£o foram criados tr√™s diferentes objetos do tipo **Aluno**. Isso faz com que cada **objeto Aluno** (aluno1, aluno2 e aluno3) seja criado na mem√≥ria em locais diferentes (endere√ßos) e possuam espa√ßo de aloca√ß√£o de mem√≥ria diferentes para **cada atributo de cada objeto**;

4. Cada *objeto* criado √© **independente** do outro e possui valores pr√≥prios para os seus atributos (propriedades). Como a a√ß√£o √© realizada pelo objeto, cada m√©todo far√° a a√ß√£o sobre os atributos do objeto indicado, evitando que haja qualquer tipo de altera√ß√£o indevida nos valores de cada um.

![img02](https://user-images.githubusercontent.com/61624336/119909388-16166f00-bf2b-11eb-88c1-15bbf2b15e8e.jpg)

5. Operador <code>new</code> serve para criar um novo objeto e instancia-lo com <code>()</code>, portanto, √© um m√©todo construtor.

<pre>nome_da_classe nome_do_objeto = <b>new</b> m√©todo_construtor();</pre>

## üìö Biblioteca de classes e reaproveitamento de c√≥digo ‚òï

A classe **Aluno** passou a ser **uma biblioteca**, e esta classe pode ser reutilizada em diversas outras aplica√ß√µes. Esse conceito √© um dos mais importantes na programa√ß√£o orientada a objetos, pois reduz o trabalho. Qualquer classe criada poder√° ser reaproveitada in√∫meras vezes por diversas aplica√ß√µes, poupando esfor√ßo de desenvolvimento e facilitando a manuten√ß√£o.

Cada classe criada se torna uma parte da sua biblioteca de classes e, conforme voc√™ vai criando novas classes, a sua biblioteca tende a aumentar. Dessa forma, quando voc√™ for criar novas aplica√ß√µes, ter√° √† sua disposi√ß√£o uma s√©ria de classes j√° prontas e dispon√≠veis para reaproveitar, sem precisar de novas.

Se voc√™ precisar realizar qualquer melhoria em uma classe da sua biblioteca, voc√™ poder√° realizar sem problemas, pois qualquer inclus√£o n√£o afetar√° o uso desta classe nas aplica√ß√µes antigas, mantendo a compatibilidade entre todas as aplica√ß√µes.

## üõ†Ô∏è Facilidade de manuten√ß√£o ‚òï

Com base no reaproveitamento de c√≥digo da programa√ß√£o orientada a objetos, podemos realizar altera√ß√µes de melhoria, atualiza√ß√£o ou qualquer manuten√ß√£o em uma classe. Isso far√° com que todas as aplica√ß√µes sejam atualizadas quando forem recompiladas.

## ‚òï M√©todos Setters e Getters üîõ

Por quest√µes de **seguran√ßa e falta de controle**, **n√£o √© comum realizar acessos diretos aos atributos de um objeto**, por isso s√£o criados m√©todos espec√≠ficos para receber o valor e realizar a **atribui√ß√£o (Setters)**, ou para a **recupera√ß√£o (Getters)** de um valor armazenado nos atributos de um objeto. Este processo pode evitar que valores incorretos sejam atribu√≠dos sem qualquer chance de an√°lise.

### ‚òï M√©todos Setters ‚û°Ô∏è

S√£o m√©todos especiais que recebem o valor do atributo e, por serem m√©todos, podem analisar se s√£o v√°lidos, sendo respons√°veis pela atribui√ß√£o. Quando o atributo √© protegido (privado), √© necess√°rio um m√©todo para realizar a atribui√ß√£o.

Caracter√≠sticas dos m√©todos Setters:

- S√£o sempre do tipo <code>void</code>, pois m√©todos Setters n√£o devem retornar nada;

- Devem ser p√∫blicos para que a aplica√ß√£o tenha acesso ao m√©todo;

- Devem come√ßar pela palavra <code>set</code> e o nome do atributo: como tem mais de uma palavra, cada nova palavra no nome deve come√ßar por letra mai√∫scula;

- Possui sempre um par√¢metro do mesmo tipo do atributo que receber√° o valor, pois ambos (par√¢metro e atributo) devem ser do mesmo tipo.

A verifica√ß√£o do valor a ser atribu√≠do n√£o pode ser realizada quando efetuamos uma atribui√ß√£o direta:

<pre>Aluno a = new Aluno();

a.cr = -5.0;</pre>

O uso de um m√©todo Setter neste caso evitar√° que seja atribu√≠do um valor inv√°lido para o CR, no caso -5.0;

### Exemplo: Setters

![print](https://user-images.githubusercontent.com/61624336/119926413-c39a7a00-bf4d-11eb-9797-aa6ef37af735.png)

![print](https://user-images.githubusercontent.com/61624336/119926215-4f5fd680-bf4d-11eb-9d3a-96fb33b2ec6d.png)

- Note que o par√¢metro c recebe o valor a ser atribu√≠do ao CR (-5.0), mas antes de atribuir √© realizada uma verifica√ß√£o do valor para averiguar se o mesmo √© v√°lido. No caso, o valor do par√¢metro √© menor do que zero.

- Como sabemos que um CR n√£o pode ser negativo, a atribui√ß√£o n√£o ser√° realizada, assim como a tentativa de realizar a atribui√ß√£o de um CR maior do que 10 (dez) tamb√©m n√£o permitir√° que a atribui√ß√£o ocorra.

**Apenas atribui√ß√µes com valores v√°lidos poder√£o ser realizadas neste caso.**

## ‚òï M√©todos Getters ‚¨ÖÔ∏è

S√£o m√©todos especiais que **retornam o valor armazenado no atributo, evitando acesso direto a ele pela aplica√ß√£o**. Assim como visto no m√©todo Setter, a prote√ß√£o do atributo (private) far√° com que a aplica√ß√£o n√£o tenha acesso direto a ele, fazendo com que seja necess√°rio um m√©todo p√∫blico para recuperar o valor atribu√≠do ao mesmo.

Caracter√≠sticas dos m√©todos Getters:

- S√£o sempre do mesmo tipo do atributo que ser√° retornado, nunca do tipo <code>void</code>;

- Devem ser p√∫blicos para que a aplica√ß√£o tenha acesso ao m√©todo;

- Devem come√ßar pela palavra <code>get</code> e o nome do atributo: como tem mais de uma palavra, cada nova palavra no nome deve come√ßar por letra mai√∫scula;

- N√£o possui par√¢metro: esses m√©todos nunca receber√£o par√¢metros, uma vez que n√£o far√£o atribui√ß√µes ou a√ß√µes com par√¢metros, realizando apenas o retorno do valor armazenado no atributo.

### Exemplo:

![print](https://user-images.githubusercontent.com/61624336/119929490-02333300-bf54-11eb-93ac-6fba6362af6e.png)

Note que n√£o existe par√¢metro, o m√©todo apenas deve retornar o valor armazenado e por isso n√£o pode ser <code>void</code>, sendo o tipo de retorno do mesmo tipo do atributo que ser√° retornado, e a a√ß√£o √© a de retorno (return).

**No futuro, os atributos das nossas classes ser√£o protegidos contra acesso direto (privado)**, impedindo que a aplica√ß√£o possa acessar diretamente um atributo. Dessa forma, √© necess√°rio que usemos os m√©todos *Setters* e *Getters* para atribuir e recuperar os valores do atributo.

### Exemplo: Aluno.java (vers√£o com m√©todos Setters e Getters.)

![code](https://user-images.githubusercontent.com/61624336/120033833-86c49680-bfd2-11eb-83a8-2a1379ce07ac.png)

### Exemplo: AppAluno.java (nova vers√£o)

![code](https://user-images.githubusercontent.com/61624336/120039595-9399b800-bfdb-11eb-956a-bd8c7be22f31.png)

### Notas:

1. Os valores dos atributos dos alunos 1 e 2 ser√£o atribu√≠dos normalmente, mas os valores do aluno3 n√£o, porque a matr√≠cula e o nome est√£o vazios e o CR n√£o √© v√°lido;

2. Os valores foram atribu√≠dos utilizando os m√©todos Setters, que verificaram se os valores eram v√°lidos para s√≥ ent√£o realizar as atribui√ß√µes;

3. Os m√©todos Getters foram usados na pr√≥pria classe Aluno para buscar os valores armazenados nos atributos do objeto no m√©todo imprimir.

## Exemplo pr√°tico

A classe **Carro** possui os atributos e m√©todos a seguir, crie a **classe Carro** e a **aplica√ß√£o AppCarro**, realize a entrada de dados na aplica√ß√£o atrav√©s do teclado, e ao final imprima os dados dos respectivos carros (atrav√©s do m√©todo <code>imprimir()</code>).

### üöò Classe Carro üöó:

<table>

<tr>
  <td><b>Atributos</b></td>
  <td><b>M√©todos</b></td>
</tr>

<tr>
  <td>Fabricante: texto</td>
  <td>- <i>Setters</i> para todos os atributos</td>
</tr>

<tr>
  <td>Modelo: texto</td>
  <td>- <i>Getters</i> para todos os atributos</td>
</tr>

<tr>
  <td>Cor: texto</td>
  <td>- <b>Imprimir()</b> // imprime todos os atributos</td>
</tr>

<tr>
  <td>Placa: texto</td>
</tr>

<tr>
  <td>Valor: real</td>
</tr>

<tr>
  <td>N√∫mero de Portas: inteiro</td>
</tr>

<tr>
  <td>Ano de fabrica√ß√£o: inteiro</td>
</tr>

<tr>
  <td>Ano do Modelo: inteiro</td>
</tr>

</table><br \>

### üöò Solu√ß√£o do exerc√≠cio pr√°tico ‚òï

#### Carro.java

![Carro](https://user-images.githubusercontent.com/61624336/120238115-a22ddc80-c232-11eb-8a1e-02ac44164306.png)

#### AppCarro.java

![AppCarro](https://user-images.githubusercontent.com/61624336/120238324-ab1eae00-c232-11eb-9504-872fe4511b68.png)

### Notas:

Voc√™ pode ver que temos algumas repeti√ß√µes de c√≥digo para realizar a entrada de dados de cada objeto. Se aumentarmos o n√∫mero de objetos, aumentaremos consideravelmente o tamanho do c√≥digo.

Para resolver este problema e evitarmos a redund√¢ncia de c√≥digos, vamos incluir um novo m√©todo na classe Carro, um m√©todo para a entrada de dados. Desta forma, evitamos a redund√¢ncia dos c√≥digos de entrada de dados.

## Classe Carro

<table>
  <tr>
    <td><b>Atributos</b></td>
    <td><b>M√©todos</b></td>
  </tr>
  <tr>
    <td>Fabricante: texto</td>
    <td>- Setters para todos os atributos</td>
  </tr>
  <tr>
    <td>Modelo: texto</td>
    <td>- Getters para todos os atributos</td>
  </tr>
   <tr>
    <td>Cor: texto</td>
    <td>Imprimir() // imprime todos os dados do carro</td>
  </tr>
  <tr>
    <td>Placa: texto</td>
    <td>- EntradaDados () // realiza a entrada de dados do carro</td>
  </tr>
  <tr>
    <td>Valor: real</td>
  </tr>
  <tr>
    <td>Valor: real</td>
  </tr>
  <tr>
    <td>NumeroPortas: inteiro</td>
  </tr>
  <tr>
    <td>AnoFabricacao: inteiro</td>
  </tr>
  <tr>
    <td>AnoModelo: inteiro</td>
  </tr>
</table>

## Nova solu√ß√£o do exerc√≠cio pr√°tico, com a inclus√£o do m√©todo entradaDados na classe Carro:

### Aluno.java
![code](https://user-images.githubusercontent.com/61624336/120251160-05316a80-c257-11eb-8ad1-8f93cc44a765.png)

### AppAluno.java
![code2](https://user-images.githubusercontent.com/61624336/120251170-0febff80-c257-11eb-8ab6-a7a026cca2f5.png)

### Nota
Voc√™ pode perceber agora que existe um m√©todo para a entrada de dados na classe Carro, e que ele est√° sendo usado por cada carro para realizar a entrada de dados pelo teclado, evitando que os c√≥digos das entradas de dados fiquem redundantes.

Al√©m disso, a aplica√ß√£o ficou muito mais simples. Caso voc√™ tenha v√°rios objetos carros, voc√™ n√£o ter√° redund√¢ncia, portanto sua aplica√ß√£o ficar√° mais simples.

Fa√ßa um teste executando a nova aplica√ß√£o e analise o resultado. Inclua mais dois objetos carros e teste novamente: voc√™ ver√° que a aplica√ß√£o ter√° uma pequena mudan√ßa, mas a classe Carro ficar√° inalterada.

A partir deste momento, todas as classes dever√£o sempre conter o <code>m√©todo entradaDados()</code>.

<hr>

<h1 align="center">Cap 04: ‚òï M√©todos construtores e polimorfismo de sobrecarga ü•®</h1>

## Primeiras palavras

A programa√ß√£o orientada a objetos permite que possamos controlar a cria√ß√£o de um objeto atrav√©s dos chamados **m√©todos construtores**. Tal caracter√≠stica permite que um m√©todo especial, o **m√©todo construtor**, seja executado no momento em que ocorre a cria√ß√£o do objeto (objeto √© instanciado) e um conjunto de a√ß√µes (instru√ß√µes) podem ser programadas para serem realizadas neste momento.

Entre essas a√ß√µes, pode-se destacar o recebimento de dados iniciais para serem atribu√≠dos e/ou preparar o objeto para que este esteja apto a atender √†s necessidades para qual foi criado.

Um *m√©todo construtor* pode ainda ser usado para determinar o tamanho de um vetor que ser√° usado pelo objeto, assim como *pr√©-configurar estruturas de dados de suporte* ao objeto que est√° sendo criado.

## ‚òï M√©todos construtores üß±

S√£o m√©todos especiais executados apenas uma vez por cada *objeto* criado, pois somente s√£o executados no momento da **instancia√ß√£o / cria√ß√£o do objeto**, sendo respons√°veis por realizar as a√ß√µes necess√°rias para a sua cria√ß√£o (controlar a cria√ß√£o do objeto).

Caracter√≠sticas dos m√©todos construtores:

1. S√£o sempre p√∫blicos (public, caracter√≠stica de encapsulamento ‚Äì veremos mais adiante), n√£o podendo ter nenhum tipo de restri√ß√£o;

2. N√£o existe defini√ß√£o de tipo de retorno, pois m√©todos construtores n√£o podem retornar valores com a instru√ß√£o ‚Äúreturn‚Äù, s√£o sem tipo;

3. Devem ser identificados sempre com o mesmo nome da classe;

4. S√£o executados exclusivamente durante o processo de cria√ß√£o / instancia√ß√£o do objeto, n√£o podendo ser usados pelo objeto ap√≥s a sua cria√ß√£o.

### Pessoa.java

![code](https://user-images.githubusercontent.com/61624336/120386438-fef6c900-c2fe-11eb-81f3-359dcbaf7019.png)

### AppPessoa.java

![code1](https://user-images.githubusercontent.com/61624336/120386442-00c08c80-c2ff-11eb-82ff-84f4cbf3431e.png)

### Notas

1. Na classe Pessoa, o m√©todo construtor:

<pre>public Pessoa(String nome, String identidade, int idade)</pre>

O m√©todo √© p√∫blico, n√£o possui tipo de retorno antes no nome identificador do m√©todo, seu identificador √© igual ao nome da classe, por isso come√ßou por letra mai√∫scula e s√≥ ser√° usado para criar o objeto (instanciar);

2. A partir do momento em que um m√©todo construtor √© criado, a classe s√≥ poder√° ser instanciada se usarmos um m√©todo construtor existente. Por isso, o objeto Pessoa p1 n√£o pode ser criado e sua cria√ß√£o foi comentada na aplica√ß√£o, pois este m√©todo tenta utilizar um m√©todo construtor que n√£o existe na classe;

3. O objeto p2 usa um m√©todo construtor existente e por isso pode ser criado;

4. Com o uso do m√©todo construtor, os dados recebidos como par√¢metros puderam ser utilizados para realizar as atribui√ß√µes nos atributos do objeto, determinando os valores de suas propriedades no momento da cria√ß√£o do objeto;

5. Os m√©todos setIdentidade (String id) e setIdade (int id) podem ter o mesmo identificador para o par√¢metro porque o par√¢metro id √© declarado em diferentes m√©todos e, sendo assim, ele √© v√°lido internamente em cada um dos m√©todos separadamente.

O processo de compila√ß√£o de uma classe cria um m√©todo construtor vazio quando n√£o for encontrado nenhum m√©todo construtor. Desta forma, nos exemplos anteriores, as classes Aluno e Carro n√£o tinham m√©todos construtores, ent√£o o compilador criou respectivamente os m√©todos a seguir para as classes Aluno e Carro:

<pre>public Aluno ( ) { }

e

public Carro ( ) { }</pre>

Quando n√£o temos um construtor em uma classe, um construtor VAZIO √© criado no processo de compila√ß√£o.

## ‚òï Polimorfismo de sobrecarga ü•®

**Polimorfismo** quer dizer muitas formas. O **polimorfismo de sobrecarga** permite o emprego de operadores e identificadores de v√°rias formas, sendo ent√£o necess√°ria uma contextualiza√ß√£o para que seja realizada a opera√ß√£o adequada. Este contexto est√° ligado ao emprego do operador, m√©todo etc., de acordo com uma situa√ß√£o.

### ‚òï Polimorfismo de sobrecarga de operadores ü•® +

![code](https://user-images.githubusercontent.com/61624336/120408734-fcf43080-c325-11eb-890b-a76dc584a7db.png)

A mudan√ßa de contexto faz com que as opera√ß√µes a serem realizadas sejam diferentes, pois toda linguagem de programa√ß√£o possui diferentes formas de realizar as opera√ß√µes de soma inteira e real. Desta forma, a express√£o aritm√©tica a seguir utiliza as duas opera√ß√µes conjuntamente:

<pre>double z = ( 2 + 5) / (3.5 + 1.5);</pre>

Na primeira opera√ß√£o de soma, os operandos s√£o inteiros, ent√£o a opera√ß√£o a ser realizada ser√° de uma soma inteira, para somente depois ser realizada a opera√ß√£o de soma real. Desta forma, teremos em um instante a seguinte situa√ß√£o:

<pre>double z = ( 7) / (5.0);</pre>

Assim, a opera√ß√£o de divis√£o ser√° real e n√£o inteira porque existe um operando real.

### Coment√°rio

Em Java, **todas as opera√ß√µes aritm√©ticas ser√£o realizadas em fun√ß√£o dos tipos dos operandos**, e a opera√ß√£o ser√° inteira apenas se ambos os operandos foram inteiros. Caso contr√°rio (um operando inteiro e outro real ou dois operandos reais), a opera√ß√£o ser√° real.

O operador <code>+</code> √© um dos mais usados, sendo um bom exemplo de **sobrecarga de operadores**, pois pode ser utilizado de v√°rias e diferentes formas em fun√ß√£o do contexto:

1. Concatena√ß√£o: <code>String nome = "Jo√£o" + " da " + "Silva";</code>
2. Soma inteira: <code>int a = 3 + 4;</code>
3. Soma real: <code>double b = 1.3 + 2.7;</code>
4. Incremento: <code>x++; ou ++x;</code>
5. Concatena√ß√£o entre textos e valores: <code>System.out.println("Idade" + p2.getIdade());</code>

Agora imagine a seguinte instru√ß√£o:

<pre>System.out.println("Valor =" + (( 3 + 4) + (1.3 + 2.7) + (++x)));</pre>

A *sobrecarga de operadores* est√° sendo usada de diferentes formas em uma mesma instru√ß√£o. Cada contexto ser√° avaliado para que seja executada a opera√ß√£o adequada em cada caso.

Toda express√£o √© avaliada sintaticamente, assim como cada contexto ser√° avaliado individualmente no momento da execu√ß√£o.

## ‚òï Polimorfismo de sobrecarga de m√©todos ü•®üßë‚Äçüè´

A **sobrecarga de m√©todos** permite que possamos ter mais de um m√©todo com o mesmo identificador em uma mesma classe. Isso s√≥ √© poss√≠vel em raz√£o da avalia√ß√£o do contexto no momento da execu√ß√£o. Vamos levar em considera√ß√£o que eu desejo realizar o c√°lculo da √°rea de um quadrado e de um ret√¢ngulo em uma mesma classe.

Para realizar o c√°lculo da √°rea do quadrado, eu preciso apenas do valor da base do quadrado. Assim, o m√©todo √°rea ficaria da seguinte forma:

![code](https://user-images.githubusercontent.com/61624336/120410374-3da17900-c329-11eb-8fbc-188422df67b8.png)

J√° para realizar o c√°lculo da √°rea do ret√¢ngulo, eu preciso do valor da base e da altura do quadrado. Assim, o m√©todo √°rea ficaria da seguinte forma:

![code](https://user-images.githubusercontent.com/61624336/120410630-bd2f4800-c329-11eb-8232-7ef0f6245d9f.png)

## ‚òï Assinaturas ‚úíÔ∏è
Esses **dois m√©todos podem conviver na mesma classe**, uma vez que eles possuem **diferentes assinaturas**. A **assinatura de um m√©todo** √© determinada pelo *tipo de par√¢metros* e pela *ordem em que estes foram declarados*. Desta forma, a assinatura do primeiro m√©todo √©:

```java
area ( int );
```

e do segundo:

```java
area ( int , int );
```

Diante da diferen√ßa de assinaturas, podemos ter dois diferentes contextos para o uso do m√©todo de c√°lculo da √°rea:

1. <pre>System.out.println("√Årea = " + area( 5 ));</pre>

No primeiro contexto, √© chamado para executar o m√©todo √°rea com um √∫nico par√¢metro e neste caso a avalia√ß√£o em tempo de execu√ß√£o ir√° determinar que deve ser usado o c√°lculo da √°rea do quadrado. Ou seja, aquele que recebe um valor inteiro como par√¢metro, e a resposta ser√°: <code>25</code>.

2. <pre>System.out.println("√Årea = " + area( 5, 6 ));</pre>

No segundo contexto, √© chamado para executar o m√©todo √°rea com um dos par√¢metros e, neste caso, a avalia√ß√£o em tempo de execu√ß√£o ir√° determinar que deve ser usado o c√°lculo da √°rea do ret√¢ngulo. Ou seja, aquele que recebe dois valores inteiros como par√¢metro, e a resposta ser√°: <code>30</code>.

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è
Com o uso da sobrecarga de m√©todos voc√™ poder√° criar quantos m√©todos com o mesmo identificador (nome) quiser em uma mesma classe, desde que eles **n√£o possuam a mesma assinatura de m√©todo**.

## M√©todos
Se quisesse incluir um m√©todo para calcular a **√°rea de uma circunfer√™ncia**, voc√™ n√£o poderia incluir **nesta classe**, pois ele teria a mesma assinatura do m√©todo do c√°lculo da √°rea do quadrado:

![code](https://user-images.githubusercontent.com/61624336/120411706-9eca4c00-c32b-11eb-9041-9fee2bdce201.png)

O m√©todo teria a mesma assinatura do m√©todo **√°rea do quadrado** e, no momento da execu√ß√£o, n√£o haveria como saber qual dos dois deveria seria executado, pois ambos teriam o mesmo contexto:

<pre>System.out.println("√Årea Quadrado = " + area( 5 ));</pre>
<pre>System.out.println("√Årea Circunfer√™ncia = " + area( 4 ));</pre>

A linguagem Java n√£o teria como definir qual m√©todo executar, j√° que ambos t√™m a mesma assinatura e a linguagem n√£o √© suficientemente inteligente para tentar buscar isso em algum outro lugar que n√£o o contexto da chamada do m√©todo:

<pre>area( 5 )

e

area( 4 )</pre>

Como ambos possuem o mesmo contexto, os m√©todos com a mesma assinatura n√£o podem compartilhar a mesma classe.

### Exemplos de polimorfismo de sobrecarga v√°lidos para uma mesma classe:

![code](https://user-images.githubusercontent.com/61624336/120412490-07fe8f00-c32d-11eb-9121-6c8bfce3ea88.png)

### As assinaturas s√£o respectivamente:

![code](https://user-images.githubusercontent.com/61624336/120412911-c3272800-c32d-11eb-9da7-9f4f1921a5c1.png)

Todos os m√©todos acima, apesar de possu√≠rem a mesma quantidade de par√¢metros, t√™m assinaturas diferentes que ser√£o executadas em fun√ß√£o de contexto diferentes, respectivamente:

![code](https://user-images.githubusercontent.com/61624336/120413132-1f8a4780-c32e-11eb-8815-16a432a0aad1.png)

Os valores armazenados em g, h, i e j ser√£o respectivamente: 1, 2, 3 e 4.

## ‚òï A sobrecarga de m√©todos construtores ü•®üß±

**M√©todos construtores** s√£o m√©todos e **tamb√©m podem ser sobrecarregados**.

Uma classe que possui mais de um m√©todo construtor √© uma classe que oferece diferentes formas de cria√ß√£o para os seus objetos.

Outra forma de uso de *mais de um construtor* √© para manter a **compatibilidade de uma classe com suas aplica√ß√µes antigas**.

Se analisarmos a <code>classe Carro</code>, vista como exemplo anteriormente, podemos notar que ela **n√£o possui nenhum m√©todo construtor**. Podemos ent√£o criar alguns m√©todos construtores para esta classe e preservar a aplica√ß√£o antiga, criando e analisando uma classe nova (evolu√≠da) e as duas aplica√ß√µes, a antiga e a nova:

### Classe: Carro (atualizada com cinco m√©todos construtores).

![code](https://user-images.githubusercontent.com/61624336/120420000-de983000-c339-11eb-9488-b90efb896231.png)

### Aplica√ß√£o antiga AppCarro.
![code](https://user-images.githubusercontent.com/61624336/120421372-8878bc00-c33c-11eb-8505-9a0825f440e3.png)

A execu√ß√£o da aplica√ß√£o n√£o foi afetada pelas mudan√ßas na classe porque foi criado o construtor vazio <code>public Carro ( ) { }</code> que garantiu a compatibilidade:

### Aplica√ß√£o usando diferentes construtores para criar os objetos: AppCarro.

![code](https://user-images.githubusercontent.com/61624336/120423047-038fa180-c340-11eb-8894-6b52a1f12313.png)

### Notas:

1. O primeiro m√©todo construtor criado foi o vazio, para garantir a compatibilidade com a aplica√ß√£o antiga;
2. Foram inclu√≠dos mais quatro m√©todos construtores seguindo o conceito da sobrecarga de m√©todos;
3. Na nova aplica√ß√£o, foram criados cinco diferentes objetos, cada um usando um construtor diferente;
4. Ambas as aplica√ß√µes funcionaram apesar da altera√ß√£o;

## ‚òï Polimorfismo de sobrecarga e a evolu√ß√£o das classes ü•®

Com o **polimorfismo de sobrecarga** podemos criar **diferentes implementa√ß√µes para m√©todos com o mesmo identificador (nome) em uma mesma classe**.

Vamos imaginar que uma classe chamada **Login** fosse usada por v√°rios de seus sistemas:

### Login.java

![code](https://user-images.githubusercontent.com/61624336/120426078-cb8b5d00-c345-11eb-8d72-01414960c525.png)


### AppLogin.java

![code](https://user-images.githubusercontent.com/61624336/120427380-30e04d80-c348-11eb-8bc3-e7a533fd602b.png)

Imagine a situa√ß√£o: voc√™ tem um *novo cliente*, e seus funcion√°rios fazem o login n√£o apenas com o nome de login e a senha, mas tamb√©m utilizando um dispositivo eletr√¥nico para gera√ß√£o de senhas (token).

A sua classe n√£o iria funcionar com este novo contexto. Neste caso, a programa√ß√£o orientada a objetos nos ajuda muito, pois faremos uma atualiza√ß√£o na classe Login e ela ser√° capaz, n√£o s√≥ de atender a esta nova demanda, mas de continuar a atender os antigos clientes.

### Classe Atualizada: Login
![code](https://user-images.githubusercontent.com/61624336/120578541-5dee3800-c3fc-11eb-98a9-cc027d250441.png)

### Aplica√ß√£o: AppLogin com um objeto usando o novo construtor.
![code1](https://user-images.githubusercontent.com/61624336/120578549-60e92880-c3fc-11eb-89fe-8998386427fc.png)

### Notas:

01. A classe Login agora possui dois diferentes construtores e dois diferentes m√©todos verificaLogin, **ambos sobrecarregados**. A vers√£o anterior foi preservada porque ainda √© usada pelos sistemas dos antigos clientes. Entretanto, com a inclus√£o dos novos m√©todos, a classe foi atualizada e tamb√©m passou a atender ao cliente novo;

02. Foi inclu√≠do ainda o m√©todo verificarToken, que s√≥ √© usado pelo cliente novo. Sua inclus√£o na classe n√£o atrapalha em nada os sistemas dos clientes antigos;

03. A aplica√ß√£o agora pode instanciar (criar) objetos das duas formas, com e sem o token, sem que uma atrapalhe a outra.

As classes na programa√ß√£o orientada a objetos evoluem conforme precisamos de mais atributos e m√©todos.

Entretanto, se mantivermos os m√©todos necess√°rios para os sistemas mais antigos, essa evolu√ß√£o n√£o afetar√° os outros sistemas e teremos uma melhoria na classe, facilitando a sua evolu√ß√£o e sua manuten√ß√£o, uma vez que, ao realizar qualquer melhoria em uma classe, basta recompilar as aplica√ß√µes que estas se tornar√£o atualizadas.

### Exerc√≠cio

Analisando os m√©todos abaixo (para uma mesma classe), podemos afirmar que foi aplicado o conceito de polimorfismo de sobrecarga?

<pre>double calculo(double p, double a) {

return p+a;

}

double calculo(double p, double a) {

return a*p;

}

double calculo(double p, double a, double t) {

return p-a+t;

}</pre>

### Resolu√ß√£o

N√£o, apesar dos m√©todos possu√≠rem o mesmo nome, eles n√£o possuem a mesma assinatura.

Assinaturas:

<pre>double calculo(double, double)

double calculo(double, double)

double calculo(double, double, double)</pre>

<hr>

<h1 align="center">Cap 05: ‚òï Heran√ßa üçá</h1>

A programa√ß√£o orientada a objetos tem como um dos principais pilares o "reaproveitamento de c√≥digo". <b>Reaproveitar o c√≥digo</b> significa menos esfor√ßo em seu desenvolvimento e mais facilidade na manuten√ß√£o do sistema. Ao evitarmos a redund√¢ncia de c√≥digo, fica mais f√°cil gerar altera√ß√µes, uma vez que n√£o precisaremos modific√°-lo em v√°rios locais diferentes.

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

A **heran√ßa** √© um conceito muito importante que *possibilita identificar duas ou mais classes que possuam semelhan√ßas*. Estas podem ser definidas atrav√©s de *uma hierarquia*, em que os membros comuns √†s **duas ou mais classes passam para uma nova classe**, conhecida como **Superclasse** ou **classe ‚Äúm√£e‚Äù**.

J√° as **classes originais** permanecer√£o apenas com os membros n√£o comuns, sendo denominadas **Subclasses** ou **classes ‚Äúfilhas‚Äù**. Ao aplicar este conceito, podemos trabalhar com uma hierarquia entre as classes, em que as de **maior hierarquia** *aglutinam os membros comuns* e as de **menor hierarquia** possuem *apenas membros distintos entre elas*.

## ‚òï Tipos de heran√ßa üçá
Em algumas linguagens de programa√ß√£o no conceito de POO se trabalha muito com os dois tipos de heran√ßa. Entretanto, a linguagem Java n√£o trabalha com Heran√ßas m√∫ltiplas, somente com heran√ßa simples.

### üçá Heran√ßa Simples ‚úîÔ∏è
Em Java, temos **apenas** a implementa√ß√£o da *heran√ßa simples*. A **heran√ßa simples** se caracteriza por **cada classe herdar sempre de apenas uma outra classe por vez**. Devemos observar que, mesmo que tenhamos uma sequ√™ncia de classes herdando, em que uma herda da outra, ainda assim, temos a heran√ßa simples, que pode ser observada nos exemplos das figuras a seguir:

![img02](https://user-images.githubusercontent.com/61624336/120694581-c979e900-c480-11eb-8366-93a82d90a124.jpg)

![img03](https://user-images.githubusercontent.com/61624336/120694670-deef1300-c480-11eb-8e90-7ed645c85526.jpg)

![img04](https://user-images.githubusercontent.com/61624336/120694709-e9111180-c480-11eb-93f3-6f8bed85d319.jpg)

![img05](https://user-images.githubusercontent.com/61624336/120694981-32616100-c481-11eb-81ec-ad1f071fa66f.jpg)

### Nota:
Em todos os casos, temos sempre a *heran√ßa simples*, pois cada classe sempre herda **apenas** da sua *classe superior*, mesmo se incluirmos novos n√≠veis.

## üçá Heran√ßa M√∫ltipla ‚ùå
A **heran√ßa m√∫ltipla** se caracteriza quando uma mesma classe herda de duas ou mais classes ao mesmo tempo. Java n√£o permite a implementa√ß√£o da heran√ßa m√∫ltipla; mesmo este sendo um conceito da programa√ß√£o orientada a objetos, algumas linguagens de programa√ß√£o n√£o implementam este conceito. A linguagem C permite a implementa√ß√£o de heran√ßa m√∫ltipla, mas Java e C#, por exemplo, n√£o permitem esta implementa√ß√£o.

A heran√ßa m√∫ltipla pode ser observada nos exemplos das figuras a seguir:

![img06](https://user-images.githubusercontent.com/61624336/120702327-54131600-c48a-11eb-8e60-336c6f8a3191.jpg)

![img07](https://user-images.githubusercontent.com/61624336/120708698-482b5200-c492-11eb-97e7-d2ea8ed6125e.jpg)

## Heran√ßa em Java
Vejamos um exemplo:

Sejam as tr√™s classes a seguir referentes a uma empresa:

<table>
<tr>
 <td>Classe</td>
 <td>Atributos</td>
 <td>Atributos</td>
</tr>
<tr>
 <td><b>Gerente</b></td>
 <td>
 Identidade: texto
 
 Nome: texto
 
 Matr√≠cula: texto
 
 Sal√°rio: real
 
 PercentualVenda: real
 
 N√≠velGerente: inteiro
 </td>
<td>
  <ul>
    <li>Setters [para todos os atributos]</li>
    <li>Getters [para todos os atributos]</li>
    <li>Construtores [m√≠nimo 5]</li>
    <li>Imprimir [para exibir os atributos]</li>
    <li>EntradaDados [para todos os atributos]</li>
    <li>Cadastrar [atribui a todos os atributos]</li>
  </ul>
</td>
</tr>
<tr>
  <td><b>Funcion√°rio</b></td>
  <td>
   Identidade: texto

   Nome: texto

   Matr√≠cula: texto

   Sal√°rio: real

   Setor: texto

   NomeGerente: texto
  </td>
  <td>
    <ul>
     <li>Setters [para todos os atributos]</li>
     <li>Getters [para todos os atributos]</li>
     <li>Construtores [m√≠nimo 5]</li>
     <li>Imprimir [para exibir os atributos]</li>
     <li>EntradaDados [para todos os atributos]</li>
     <li>Cadastrar [atribui a todos os atributos]</li>
    </ul>
  </td>
</tr>
<tr>
  <td><b>Cliente</b></td>
  <td>
    Identidade: texto

    Nome: texto
 
    C√≥digoCliente: texto

    Idade: inteiro

    Telefone: texto
  </td>
  <td>
     <ul>
      <li>Setters [para todos os atributos]</li>
      <li>Getters [para todos os atributos]</li>
      <li>Construtores [m√≠nimo 5]</li>
      <li>Imprimir [para exibir os atributos]</li>
      <li>EntradaDados [para todos os atributos]</li>
      <li>Cadastrar [atribui a todos os atributos]</li>
     </ul>
  </td>
</tr>
</table>

Ao analisar as classes, podemos afirmar que teremos que repetir a declara√ß√£o dos atributos **Identidade** e **Nome** em todas elas, bem como os m√©todos **Setters** e **Getters** destes atributos em todas as tr√™s classes, sem contar que ainda teremos que repetir parte da codifica√ß√£o dos m√©todos **cadastrar**, **imprimir** e **entradaDados**.

Neste caso, podemos aplicar os conceitos de **heran√ßa** e teremos a seguinte estrutura para atender ao problema descrito acima:

![img08](https://user-images.githubusercontent.com/61624336/120713682-a1967f80-c498-11eb-9a70-f98b89632c26.jpg)

- Como os atributos Identidade e Nome s√£o comuns √†s tr√™s classes, eles ficar√£o na Superclasse de maior hierarquia;
- Como os atributos Matr√≠cula e Sal√°rio pertencem somente √†s classes Gerente e Funcion√°rio, teremos uma classe intermedi√°ria chamada PessoaEmpresa, que herdar√° da classe Pessoa, mas esta tamb√©m ser√° uma Superclasse para as classes Gerente e Funcion√°rio;
- A classe Cliente herdar√° da classe Pessoa;
- As classes Gerente e Funcion√°rio herdar√£o da classe PessoaEmpresa.

Desta forma, n√£o teremos redund√¢ncia de c√≥digos, escreveremos menos linhas e teremos maior facilidade na manuten√ß√£o das classes da nossa biblioteca de classes.

Vamos analisar agora as diferen√ßas entre as vers√µes das nossas classes com e **sem a aplica√ß√£o da heran√ßa**:

## Classe Gerente sem o uso do conceito de heran√ßa:

![code](https://user-images.githubusercontent.com/61624336/120906829-12719f00-c633-11eb-875f-7ca163c6e07c.png)

## Classe Funcion√°rio sem o uso do conceito de heran√ßa:

![code1](https://user-images.githubusercontent.com/61624336/120907573-1b656f00-c639-11eb-9eb6-5383db64336f.png)

## Classe Cliente sem o uso do conceito de heran√ßa:


Vamos a algumas perguntas:

- Se for necess√°rio incluir um novo atributo com o CPF em todas as classes?
Resposta: Teremos que alterar todas as classes, dificultando a manuten√ß√£o.

- Se for necess√°rio um novo atributo para armazenar a data de admiss√£o para Gerentes e Funcion√°rios?
Resposta: Ser√° necess√°rio alterar as classes Gerente e Funcion√°rio.

- Se for necess√°rio incluir a data da primeira compra do cliente?
Resposta: Ser√° necess√°rio alterar apenas a classe Cliente.

Vamos guardar estas perguntas e repeti-las ap√≥s a aplica√ß√£o da heran√ßa.

## Aplicando os conceitos de heran√ßa:

Primeiro de tudo, vamos arquitetar o conceito de superclasses e subclasses:

- **SuperClasse**: Pessoa;
- **SubClasse de Pessoa**: PessoaEmpresa, Cliente; 
- **SubClasse de PessoaEmpresa**: Gerente, Funcionario. 

Logo, iremos aplicar esse conceito:

### Classe Pessoa com o uso do conceito de heran√ßa (SuperClasse):

![code](https://user-images.githubusercontent.com/61624336/120913193-89c32500-c66b-11eb-94b9-669f12caa596.png)

### Classe PessoaEmpresa com o uso do conceito de heran√ßa (SubClasse de Pessoa):

![code](https://user-images.githubusercontent.com/61624336/120913772-fe985e00-c66f-11eb-8a5f-29f525201230.png)

### Classe Gerente com o uso do conceito de heran√ßa (SubClasse de PessoaEmpresa):

![code](https://user-images.githubusercontent.com/61624336/120914141-694a9900-c672-11eb-8825-1d677e8c40fc.png)

### Classe Funcion√°rio com o uso do conceito de heran√ßa (SubClasse de PessoaEmpresa):

![code](https://user-images.githubusercontent.com/61624336/120934666-a1cf8e80-c6d5-11eb-96c0-b28ec46734d9.png)

### Classe Cliente com o uso do conceito de heran√ßa (SubClasse de Pessoa):

![code](https://user-images.githubusercontent.com/61624336/120969534-a1b8a880-c740-11eb-8ae1-4ff30254b352.png)

Vamos responder novamente √†s tr√™s perguntas feitas anteriormente:

- Se for necess√°rio incluir um novo atributo com o CPF em todas as classes?
Resposta: Teremos que alterar apenas a classe Pessoa, uma vez que todas as demais classes ir√£o herdar qualquer atualiza√ß√£o nesta classe.

- Se for necess√°rio um novo atributo para armazenar a data de admiss√£o para Gerentes e Funcion√°rios?
Resposta: Ser√° necess√°rio alterar apenas a classe PessoaEmpresa, j√° que as classes Gerente e Funcion√°rio herdar√£o desta classe.

- Se for necess√°rio incluir a data da primeira compra do cliente?
Resposta: Ser√° necess√°rio alterar apenas a classe Cliente.

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

Ap√≥s analisarmos as duas solu√ß√µes, chegamos √† conclus√£o de que, ao utilizar a *heran√ßa*, n√£o s√≥ evitamos a **redund√¢ncia de c√≥digos (repeti√ß√£o)** como *facilitamos a manuten√ß√£o*, uma vez que, para realizar qualquer atualiza√ß√£o, deveremos sempre alterar **apenas** *uma das classes*.

No final, a **classe Gerente** √© composta por todos os membros de **Pessoa**, **PessoaEmpresa** e **Gerente**, uma vez que Gerente estende PessoaEmpresa, que por sua vez estende a classe Pessoa:

<pre>Pessoa +
PessoaEmpresa +
Gerente</pre>

O mesmo ocorre com a classe Funcion√°rio, composta por todos os membros de Pessoa, PessoaEmpresa e Funcion√°rio, uma vez que Funcion√°rio estende PessoaEmpresa, que por sua vez estende a classe Pessoa:

<pre>Pessoa +
PessoaEmpresa +
Funcion√°rio</pre>

J√° a classe Cliente √© composta por todos os membros de Pessoa e Cliente, uma vez que Cliente estende a classe Pessoa:

<pre>Pessoa +
Cliente</pre>

## üçá Heran√ßa de m√©todos construtores üß±

Vamos analisar os m√©todos construtores da classe Cliente:

![code](https://user-images.githubusercontent.com/61624336/120968564-68336d80-c73f-11eb-8327-c36c4c87a0cd.png)

Alguns destes m√©todos repassam os par√¢metros recebidos para a **Superclasse**, atrav√©s da palavra reservada <code>super</code>. Esta instru√ß√£o diz ao compilador que o(s) par√¢metro(s) ser√°(√£o) repassado(s) a um m√©todo construtor com a *mesma assinatura na SuperClasse*.

Assim, o m√©todo:

![code](https://user-images.githubusercontent.com/61624336/120941213-d2282480-c6f7-11eb-89e7-37ff6e1364ab.png)
![code](https://user-images.githubusercontent.com/61624336/120941168-a2791c80-c6f7-11eb-84f4-bd03dcdc2df2.png)
![code](https://user-images.githubusercontent.com/61624336/120941234-e9ffa880-c6f7-11eb-880b-bbdf3f538fbf.png)

O m√©todo:

![code](https://user-images.githubusercontent.com/61624336/120941545-9d1cd180-c6f9-11eb-98e1-00ecc736079d.png)
![code](https://user-images.githubusercontent.com/61624336/120941586-cd647000-c6f9-11eb-8e88-ae99830f0db6.png)
![code](https://user-images.githubusercontent.com/61624336/120942042-92177080-c6fc-11eb-9dfb-1ab0dad67edf.png)

Por final o m√©todo:

![code](https://user-images.githubusercontent.com/61624336/120944419-c3973880-c70a-11eb-9df1-6f45d803569e.png)
![code](https://user-images.githubusercontent.com/61624336/120944378-82068d80-c70a-11eb-8aa9-d43c15ad512c.png)
![code](https://user-images.githubusercontent.com/61624336/120944888-43be9d80-c70d-11eb-8de1-63d524e88747.png)

Todo m√©todo construtor de uma SubClasse deve referenciar um construtor da SuperClasse, isso quer dizer que para o construtor vazio: <code>public Cliente() { }</code>, ser√° obrigat√≥rio que exista um construtor vazio na SuperClasse: <code>public Pessoa() { }</code>.

## Sobrescrita de m√©todos
M√©todos de uma *SuperClasse* podem ser **sobrescritos** em suas *subclasses*, implicando que um m√©todo descrito na *Superclasse* poder√° ser substitu√≠do na *Subclasse*. Para isso, √© importante observar que estes m√©todos devem possuir as mesmas assinaturas. Caso contr√°rio, ser√° usado o conceito de *Sobrecarga* e n√£o de *Sobrescrita*.

Vamos analisar o m√©todo imprimir da Superclasse Pessoa:

![code](https://user-images.githubusercontent.com/61624336/120993136-a3db3100-c759-11eb-8bc8-ecf17c716340.png)

Ele n√£o √© suficiente para atender √†s necessidades da classe Cliente, ent√£o poder√≠amos t√™-lo substitu√≠do por:

![code](https://user-images.githubusercontent.com/61624336/120993557-046a6e00-c75a-11eb-95c0-525e4b89a82b.png)

Esta substitui√ß√£o permitiria que o m√©todo imprimir fosse substitu√≠do na **Subclasse** por um m√©todo mais completo que atendesse a sua necessidade.

Note que as assinaturas dos m√©todos, tanto na **Superclasse Pessoa** como na **Subclasse Cliente**, s√£o id√™nticas: <code>imprimir( );</code> desta forma, houve uma *Sobrescrita (Override)* e n√£o uma *Sobrecarga (Overhead)*.

Como uma primeira forma de atender a demanda da classe Cliente, o m√©todo imprimir nesta nova vers√£o seria suficiente, mas podemos melhorar nossa solu√ß√£o, observe que parte do c√≥digo j√° existe no m√©todo imprimir da Superclasse Pessoa, ocorrendo uma redund√¢ncia de c√≥digo nas instru√ß√µes destacadas na cor vermelha:

![code](https://user-images.githubusercontent.com/61624336/120996631-dfc3c580-c75c-11eb-9902-eb957eb65e9c.png)

Note que as instru√ß√µes na cor vermelha j√° existem no m√©todo imprimir da Superclasse e, assim, podemos reaproveitar os c√≥digos da Superclasse ao chamar o m√©todo imprimir da Superclasse na Subclasse:

![code](https://user-images.githubusercontent.com/61624336/120996827-113c9100-c75d-11eb-920d-de4a93d2d09f.png)

Ao reaproveitar o m√©todo imprimir da Superclasse, temos dois ganhos muito importantes:

1. N√£o haver√° redund√¢ncia de c√≥digos, as instru√ß√µes do m√©todo imprimir da Superclasse ser√£o reaproveitadas na Subclasse;

2. Caso haja a necessidade de incluir um novo atributo no m√©todo imprimir, s√≥ precisaremos realizar a altera√ß√£o em apenas uma classe, pois, se for um atributo espec√≠fico da classe Cliente, s√≥ precisaremos incluir a instru√ß√£o no m√©todo da classe Cliente. Caso contr√°rio, se o atributo for comum √†s demais classes, a instru√ß√£o dever√° ser inclu√≠da apenas na Superclasse Pessoa.

A **heran√ßa** √© um conceito important√≠ssimo da programa√ß√£o orientada a Objetos, permitindo que reaproveitemos membros Superclasse, que ser√£o herdados pelas Subclasses, evitando redund√¢ncia de c√≥digos, al√©m de facilitar a manuten√ß√£o das nossas classes, uma vez que qualquer necessidade de mudan√ßa implicar√° na altera√ß√£o de apenas uma classe.

<hr>

<h1 align="center">Cap 06: ‚òï Agrega√ß√£o e particionamento ü§∞</h1>

A programa√ß√£o orientada a objetos nos ajuda a resolver de forma mais simples problemas com alta complexidade. A **agrega√ß√£o de classes** √© um conceito voltado a facilitar a solu√ß√£o de problemas muito complexos. Podemos *dividir* uma classe em classes menores, particionando esta classe em diversas outras classes mais simples, para posteriormente as reunirmos em conjunto, formando uma classe maior e mais complexa.

## Particionamento
√â a decomposi√ß√£o de classes extensas em classes menores, que podem ser mais bem reaproveitadas em outras classes, al√©m de permitir melhor controle e manuten√ß√£o.

O particionamento de classes nos permite criar objetos menores e mais simples, que poder√£o ser reunidos em conjunto, capazes de criar novas classes, maiores e mais complexas.

Vamos imaginar um computador do tipo Desktop, que √© um objeto bem complexo, com diferentes partes. Muitas dessas partes s√£o usadas por outros objetos tamb√©m, tal como Notebooks e Servidores.

Um HD (HardDisk), por exemplo, pode ser usado por cada um deles, assim como a placa de v√≠deo, a placa-m√£e, o v√≠deo, a mem√≥ria, al√©m de outros dispositivos. Se formos criar uma classe para representar um Desktop, teremos uma classe com muitos atributos, o que a tornaria grande e complexa, com muitas linhas de c√≥digo e de dif√≠cil manuten√ß√£o. Isso porque, se fosse necess√°rio realizar alguma mudan√ßa, ter√≠amos que trabalhar em uma classe altamente complexa. Outro ponto importante seria a cria√ß√£o das classes Notebook e Servidor, que seriam igualmente complexas, sem contar que, para realizar uma altera√ß√£o em um √∫nico componente que fosse, ter√≠amos que faz√™-la em todas as tr√™s classes (Desktop, Notebook e Servidor).

Inicialmente, nossa classe desktop ficaria com os seguintes atributos:

<table>
  <tr>
    <td><b>Classe</b></td>
    <td><b>Atributos</b></td>
  </tr>
  <tr>
    <td>Desktop</td>
    <td>
MarcaPlacaMae : texto
    
ModeloPlacaMae : texto

PrecoPlacaMae: real

TipoProcessador : texto

MarcaHD : texto

ModeloHD : texto

PrecoHD : real

TipoHD : texto

CapacidadeHD : inteiro

MarcaPlacaVideo : texto

ModeloPlacaVideo : texto

PrecoPlacaVideo : real

Padrao : texto

MarcaMemoria : texto

ModeloMemoria : texto

PrecoMemoria: real

TipoMemoria : texto

CapacidadeMemoria : inteiro</td>
  </tr>
</table>

Podemos analisar como ficar√° a classe Desktop:

### Declara√ß√£o dos atributos da classe Desktop:
![code](https://user-images.githubusercontent.com/61624336/121084669-5392bc00-c7b7-11eb-94b5-c9aea538887e.png)

A classe ficou extensa, complexa, sem contar que precisaremos ainda incluir os m√©todos de acesso (Setters e Getters), construtores, entradaDados, imprimir, cadastrar, al√©m de outros m√©todos que possam se fazer necess√°rios, sem contar a grande quantidade de atributos.

Observe que muitos dos atributos s√£o comuns a todas as classes e seria necess√°rio diferenciar os atributos que possuem o mesmo nome, tal como: modeloPlacaMae; modeloHD, modeloPlacaVideo, modeloMemoria etc.

O problema ainda poderia ser maior, se tiv√©ssemos mais slots de mem√≥ria, com modeloMemoria0, modeloMemoria1, modeloMemoria2, modeloMemoria3, para quatro slots, por exemplo. Essas dificuldades aumentam bastante o tamanho da classe e a sua complexidade; al√©m disso, neste exemplo, come√ßar√≠amos com 18 atributos, sem levar em considera√ß√£o a quest√£o dos diferentes slots de mem√≥ria.

Entretanto, se pensarmos segundo a √≥tica do particionamento, podemos dividir a classe Desktop, grande e complexa, em classes menores e mais simples. Como sugest√£o, poder√≠amos criar as classes que foram apresentadas como exemplo no par√°grafo anterior em:

- Placa-m√£e (PlacaMae);
- Disco R√≠gido (HD);
- Placa de v√≠deo (PlacaVideo);
- Mem√≥ria (Memoria).

A classe Desktop seria ent√£o decomposta (particionada) da seguinte forma:

![pg5](https://user-images.githubusercontent.com/61624336/121088036-8b9bfe00-c7bb-11eb-914a-0d04903807bd.png)

Vamos determinar poucos atributos para cada uma delas, apenas para entendermos melhor o conceito.

<table>
  <tr>
   <td><b>Classe</b></td>
   <td><b>Atributos</b></td>
  </tr>
  <tr>
   <td>PlacaMae</td>
   <td>
   
       Marca : texto
       
       Modelo : texto
       
       Preco : real
       
       TipoProcessador : texto
       
   </td>
  </tr>
  
  <tr>
   <td>HD</td>
   <td>
     	Marca : texto
      
      Modelo : texto
      
      Preco : real
      
      Tipo : texto
      
      Capacidade : inteiro
   </td>
  </tr>
  
  <tr>
    <td>PlacaVideo</td>
    <td>
    
    Marca : texto
    
    Modelo : texto

    Preco : real
    
    Padr√£o : texto
    
    </td>
  </tr>
  <tr>
    <td>Memoria</td>
    <td>
    
    Marca : texto
    
    Modelo : texto
    
    Preco : real
    
    Tipo : texto
    
    Capacidade : inteiro
    
    </td>
   
  </tr>
  
</table>

Assim, vamos criar as classes separadamente, dividindo a classe Desktop conforme proposto:

![code](https://user-images.githubusercontent.com/61624336/121097161-eccace00-c7c9-11eb-81e3-fe7e5d272768.png)

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

1. A decomposi√ß√£o da classe Desktop foi feita em quatro classes mais simples;
2. Os nomes dos atributos puderam ser mantidos na forma original, sem que um interfira no outro;
3. Cada classe mais simples se torna mais f√°cil de codificar;
4. As classes criadas ser√£o mais f√°ceis para se realizar qualquer tipo de manuten√ß√£o.

Outro ponto muito importante √© que todas essas classes criadas atrav√©s do particionamento poder√£o ser reaproveitadas para as classes Notebook e Servidor. Dessa forma, a nossa biblioteca de classes poder√° criar novos objetos quando reunida em conjunto.

## Agrega√ß√£o
A reuni√£o de uma ou mais classes para formar novas classes √© chamada de agrega√ß√£o. Uma nova classe pode ser formada por um conjunto de diferentes objetos. Seguindo nosso exemplo, poder√≠amos reaproveitar as classes PlacaMae, HD, PlacaVideo, e Mem√≥ria para criar novas classes, como Desktop, Notebook e Servidor, como nos exemplos a seguir:

![code](https://user-images.githubusercontent.com/61624336/121120415-e05b6b00-c7f3-11eb-8fd2-cf4ebeef81da.png)

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

1. Foram inclu√≠dos novos atributos para entendermos que a agrega√ß√£o pode incluir n√£o apenas classes, mas tamb√©m novos atributos;

2. Como toda classe √© tamb√©m um tipo, podemos declarar atributos como do tipo Classe;

3. Cada atributo criado a partir de uma classe (n√£o sendo de tipos b√°sicos) √© uma agrega√ß√£o √† classe principal, sendo assim, temos as quatro agrega√ß√µes (PlacaMae, HD, PlacaVideo e Memoria) para cada classe principal;

4. As classes Desktop, Notebook e Servidor foram criadas a partir de fragmentos menores, mas todos os atributos originais da classe Desktop est√£o presentes.

Uma oportunidade se apresenta com o uso da agrega√ß√£o, que n√£o √© poss√≠vel resolver facilmente com a heran√ßa.

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

N√£o confunda heran√ßa com agrega√ß√£o, pois s√£o conceitos diferentes.

Imagine agora a situa√ß√£o dos slots de mem√≥ria: na heran√ßa, s√≥ poder√≠amos herdar uma mem√≥ria, mas, com a agrega√ß√£o, podemos criar quantas mem√≥rias quisermos, como no exemplo a seguir. Para a classe Memoria foram criados apenas os m√©todos de Acesso (Setters e Getters) para facilitar o entendimento:

![code](https://user-images.githubusercontent.com/61624336/121124283-0afcf200-c7fb-11eb-9315-0c8f4f23d186.png)

### ‚ö†Ô∏è Aten√ß√£o ‚ö†Ô∏è

1. O Desktop possui quatro slots de mem√≥ria;

2. Como cada slot √© um objeto diferente, eles possuem propriedades diferentes, sem que nenhum tenha rela√ß√£o direta com os demais;

3. N√£o √© comum montar um computador dessa forma, mas foram definidas marcas e capacidades diferentes para indicar que os valores armazenados n√£o sofrem influ√™ncia dos demais objetos agregados.

Agora que vimos como aplicar os conceitos de agrega√ß√£o e particionamento, podemos aplicar tamb√©m o conceito de heran√ßa e melhorar nossas classes. Vamos aplicar o conceito de heran√ßa √†s nossas classes particionadas para termos uma aplica√ß√£o mais concisa e mais f√°cil para realizar manuten√ß√µes.

## Aplica√ß√£o dos conceitos de heran√ßa, particionamento e agrega√ß√£o

### Classes Particionadas

![pg14](https://user-images.githubusercontent.com/61624336/121124491-68913e80-c7fb-11eb-859a-1bd49cafeede.png)

Devemos identificar os atributos comuns √†s classes, sendo que os atributos Marca, Modelo e Pre√ßo s√£o comuns a todas as classes. J√° os atributos Tipo e Capacidade s√£o comuns apenas √†s classes HD e Memoria, sendo necess√°ria uma classe intermedi√°ria. O atributo TipoProcessador pertence apenas √† classe PlacaMae e o atributo Padr√£o pertence apenas √† classe PlacaVideo. As classes HD e Memoria n√£o ter√£o atributos espec√≠ficos, ficar√£o apenas nas superclasses.

### Classes Particionadas redefinidas ap√≥s a aplica√ß√£o da Heran√ßa

![pg14-b](https://user-images.githubusercontent.com/61624336/121125855-9f685400-c7fd-11eb-841d-b6c0f1610e5f.png)

### Classe Particionada Identifica√ß√£o:

![code](https://user-images.githubusercontent.com/61624336/121126576-c410fb80-c7fe-11eb-8b2f-21cab5a159eb.png)

### Classe Particionada Armazenamento:

![code](https://user-images.githubusercontent.com/61624336/121126687-f3c00380-c7fe-11eb-8052-5795ca008935.png)

### Classe Particionada PlacaMae:

![code](https://user-images.githubusercontent.com/61624336/121126928-587b5e00-c7ff-11eb-8724-de889f63f23f.png)

### Classe Particionada PlacaVideo:

![code](https://user-images.githubusercontent.com/61624336/121127084-a001ea00-c7ff-11eb-8c67-d88584cb9de1.png)

### Classe Particionada Memoria:

![code](https://user-images.githubusercontent.com/61624336/121127917-e86dd780-c800-11eb-962c-4d280e202af4.png)

Com a evolu√ß√£o das classes particionadas com a aplica√ß√£o do conceito de heran√ßa, foram mantidas as compatibilidades e as classes Desktop, Notebook e Servidor n√£o precisam ser alteradas, assim como a aplica√ß√£o, que funcionar√° da mesma forma que no exemplo anterior. As mudan√ßas com a evolu√ß√£o das classes particionadas n√£o afetaram as classes agregadoras, nem a aplica√ß√£o.

Caso seja necess√°ria alguma altera√ß√£o espec√≠fica, basta alterar a classe afetada. Entretanto, se for alguma altera√ß√£o sobre as classes Memoria e HD, basta alterar a classe Armazenamento; caso seja uma altera√ß√£o que afete ao mesmo tempo as quatro classes particionadas, basta alterar a superclasse Identifica√ß√£o.

Temos ent√£o um melhor controle sobre a aplica√ß√£o e maior facilidade de manuten√ß√£o de todo o sistema.

<hr>

<h1 align="center">Cap 07: ‚òï Encapsulamento üíä</h1>

O **encapsulamento** permite uma classe encapsular atributos e m√©todos, ocultando os detalhes de implementa√ß√£o dos objetos. Trabalharemos tamb√©m os tipos de visibilidade de membros de uma classe: <code>public</code>, <code>protected</code>, <code>private</code> e <code>package</code>. Desenvolveremos uma aplica√ß√£o utilizando o conceito de encapsulamento em conjunto com os conceitos de heran√ßa e agrega√ß√£o.

No desenvolvimento de aplica√ß√µes, temos situa√ß√µes nas quais a seguran√ßa √© muito importante. Em muitas situa√ß√µes os membros de uma classe (atributos e m√©todos) precisam ter o seu acesso restringido para que n√£o sejam burlados por meio das aplica√ß√µes. Esse processo de limita√ß√£o de acesso aos membros de uma classe √© chamado de **Programa√ß√£o Orientada a Objetos de Encapsulamento**.

<blockquote>‚ÄúEncapsulamento trata-se de um mecanismo que possibilita restringir o acesso a vari√°veis e m√©todos da classe (ou at√© √† pr√≥pria classe). Os detalhes de implementa√ß√£o ficam ocultos ao usu√°rio da classe, isto √©, o usu√°rio passa a utilizar os servi√ßos da classe sem saber como isso ocorre internamente. Somente uma lista das funcionalidades existentes torna-se dispon√≠vel ao usu√°rio da classe.‚Äù - (FURGERI, 2015)</blockquote>

Encapsulamento √© o processo de separa√ß√£o dos membros de uma classe atrav√©s da restri√ß√£o ao seu acesso. Pode ocultar os atributos e m√©todos de uma classe, evitando que dados e detalhes de implementa√ß√£o de m√©todos sejam vistos (acessados diretamente) pela aplica√ß√£o ou outras classes. Uma classe encapsula atributos e m√©todos, ocultando os detalhes de implementa√ß√£o dos objetos. Como um dos princ√≠pios do desenvolvimento orientado a objetos, o encapsulamento determina que a implementa√ß√£o de um objeto somente deve ser acessada atrav√©s de uma interface vis√≠vel e bem definida. Portanto, esse tipo de conceito √© o mais seguro entre todo os conceitos da POO.

Os atributos n√£o devem ser manipulados diretamente, podendo ser alterados ou consultados somente atrav√©s dos *m√©todos de acesso (Setters e Getters)* do objeto. Ao restringir o acesso direto aos atributos de uma classe, evitamos que eles sejam manipulados diretamente pela aplica√ß√£o ou outras classes, n√£o permitindo que possam receber um valor qualquer, principalmente, valores inv√°lidos para o seu contexto. Dessa forma, aumentamos a seguran√ßa e a confian√ßa sobre os valores atribu√≠dos.

Por exemplo:

### Na classe Exemplo temos o seguinte atributo:

![code](https://user-images.githubusercontent.com/61624336/121235688-7ed6e300-c86b-11eb-8f82-9c7bb4e9e2a4.png)

### Na aplica√ß√£o:

![code](https://user-images.githubusercontent.com/61624336/121256567-1431a180-c883-11eb-945e-9a899f87f10b.png)

Sa√≠da:<pre>Idade = -20</pre>

1. Como n√£o temos restri√ß√£o sobre o atributo Idade, a aplica√ß√£o poder√° realizar um acesso direto ao atributo;

2. Na aplica√ß√£o foi realizado um acesso direto ao atributo, sem o uso de um m√©todo de acesso (Setter), e o valor atribu√≠do n√£o √© v√°lido porque uma pessoa n√£o pode ter idade negativa;

3. Acesso direto aos atributos de uma classe n√£o permitem que sejam realizadas cr√≠ticas ao valor antes da atribui√ß√£o, fazendo com que o valor atribu√≠do diretamente (acesso direto) n√£o tenha qualquer tipo de valida√ß√£o.

*M√©todos* podem ter sua visibilidade restrita para evitar que detalhes de implementa√ß√£o ou um poss√≠vel uso indevido possam ser realizados por outras classes ou aplica√ß√µes. √â muito comum que um m√©todo aparentemente simples, tal como <code>calcularImposto(double valor, tipoProduto)</code> n√£o se restrinja a um simples c√°lculo. Ao se definir o <code>tipoProduto</code>, podemos ter diversas e diferentes formas de calcular o imposto sobre esse produto. Podemos ent√£o criar um m√©todo principal <code>calculaImposto()</code> e, atrav√©s dele, chamar diversos outros m√©todos, cada um respons√°vel por calcular o imposto para um determinado tipo de produto.

Realizar o acesso diretamente aos m√©todos chamados por <code>calculaImposto()</code> pode exigir muito conhecimento por parte do desenvolvedor que ir√° usar a classe, mas nem sempre este desenvolvedor ter√° os conhecimentos t√©cnicos necess√°rios. Provavelmente, houve o apoio de um especialista em processos fiscais para que o desenvolvedor original da classe pudesse desenvolver os m√©todos previstos. Para evitar o uso indevido de m√©todos que possam ser usados de forma equivocada ou com restri√ß√£o de seguran√ßa, alteramos a visibilidade desses m√©todos.

Por exemplo:

### A classe Tributos

![code](https://user-images.githubusercontent.com/61624336/121261589-4b0ab600-c889-11eb-9916-3abce6cf74a7.png)

### Na aplica√ß√£o:

![code](https://user-images.githubusercontent.com/61624336/121263973-d20d5d80-c88c-11eb-9fdc-1612a54a7995.png)

### Sa√≠da
<pre>
Digite o preco:

1000

Imposto incorreto:

Valor do imposto [atribui√ß√£o direta] = -20.0

Imposto correto, mas m√©todo errado

A faixa estava correta por acaso, porque 00 = 0

Valor do imposto[m√©todo errado 00]= 45.0

Imposto e m√©todo errados

Valor do imposto [m√©todo errado 11]= 131.0

Imposto correto, por acaso, porque 22 foi para a √∫ltima faixa

Valor a pagar [m√©todo errado 22]= 281.0

Imposto e m√©todo corretos

Valor a pagar [m√©todo correto 00]= 45.0

Imposto e m√©todo corretos

Valor a pagar [m√©todo correto 00]= 128.0

Imposto e m√©todo corretos

Valor a pagar [m√©todo correto 00]= 281.0
</pre>

1. Imaginemos que tipo de produto √© um valor entre os seguintes: [00, 01, 02, 10, 11, 12, 20, 21 e 22], em que o primeiro d√≠gito se refere ao tipo do produto e o segundo √† faixa do imposto;

2. Primeiro, o m√©todo <code>calculaImposto()</code> ir√° determinar o m√©todo a ser usado para cada tipo de imposto, e a faixa ser√° usada dentro do m√©todo espec√≠fico;

3. O m√©todo espec√≠fico ser√° chamado pelo *m√©todo principal*, que retornar√° o valor correto do imposto;

4. Se um desenvolvedor sem conhecimento correto usar diretamente um dos m√©todos espec√≠ficos, o c√°lculo poder√° resultar em um valor errado, pois dificilmente ele ir√° determinar a faixa correta, pois acabar√° por passar como par√¢metro o tipo do produto e n√£o a faixa;

5. Se os testes forem realizados apenas com os tipos entre 00 e 02, provavelmente o resultado estar√° correto porque ser√° passada apenas a faixa, mas, para os demais casos, de 10 a 12 ou de 20 a 22, provavelmente o resultado ser√° 0 (zero) ou calculado pela √∫ltima faixa;

6. Uma aplica√ß√£o ainda poder√° burlar os c√°lculos da classe, simplesmente determinando um valor ao atributo imposto [tributo.imposto = -20;], o que resultaria em um imposto incorreto, aumentando o pre√ßo do produto; como o imposto √© negativo e a opera√ß√£o aritm√©tica √© de subtra√ß√£o, haver√° um sobre pre√ßo sobre o valor.

A falta de conhecimento sobre o uso de uma classe pode gerar erros porque, mesmo realizando testes, as faixas com problemas podem n√£o ser identificadas. Para isso, devemos ocultar parte da implementa√ß√£o da classe.

## üíä Princ√≠pio do encapsulamento üíä

Atributos n√£o devem ser vis√≠veis por nenhum objeto que n√£o seja inst√¢ncia da pr√≥pria classe ou de uma classe descendente (heran√ßa).

### Tipos de encapsulamento

Na linguagem Java, temos quatro diferentes tipos de encapsulamento:

<table>
  <tr>
    <td><b>N√≠vel de restri√ß√£o:</b></td>
    <td>Tipo de Encapsulamento (modificador):</td>
  </tr>
  <tr>
    <td>
    Menor restri√ß√£o:
    
         ‚Üï 
   
    Maior restri√ß√£o:
    </td>
    
    <td>1. public ‚Äì acesso irrestrito;
    
    2. (vazio ou omiss√£o) ‚Äì acesso padr√£o (package);
    
    3. protected;
    
    4. private.</td>
  </tr>
</table>

A rela√ß√£o apresentada est√° em ordem de n√≠vel de restri√ß√£o, indo do *menos restrito* (<code>public</code>) at√© o mais *restrito* (<code>private</code>).

### Visibilidade:

- **Public**: Uma classe definida como public pode ser acessada por qualquer classe ou aplica√ß√£o, sem restri√ß√µes. Seus membros s√£o igualmente acess√≠veis (vis√≠veis) por qualquer outra classe ou aplica√ß√£o. Determina o n√≠vel menos restritivo de acesso e visibilidade aos membros (atributos e m√©todos) de uma classe;

- **Private**: Um membro definido como privado s√≥ pode ser acessado por membros da pr√≥pria classe, ou seja, apenas m√©todos existentes na pr√≥pria classe poder√£o ter acesso (visibilidade) aos atributos e m√©todos definidos como private. √â o n√≠vel com maior restri√ß√£o, pois nem mesmo subclasses dessa classe ter√£o visibilidade sobre esses membros;

- **Protected**: Um membro definido como protegido pode ser acessado apenas por membros da pr√≥pria classe, das suas subclasses e por outras classes ou aplica√ß√µes que estejam no mesmo pacote (package);

- **Default** (padr√£o, omiss√£o): Quando n√£o √© usado um modificador de encapsulamento, a visibilidade √© dita padr√£o e os membros t√™m visibilidade, ou seja, s√≥ podem ser acessados por classes e aplica√ß√µes que estejam no mesmo pacote.

### Exemplos de visibilidade de membros

- **Membros p√∫blicos**: √© a forma normal para m√©todos de acesso *(Setters e Getters)*.

![code](https://user-images.githubusercontent.com/61624336/121268767-eead9380-c894-11eb-8e47-28a2e0fcfcbf.png)

- **Membros com visibilidade padr√£o**: devemos evitar o uso do acesso padr√£o, para que tenhamos sempre a visibilidade definida.

![code](https://user-images.githubusercontent.com/61624336/121269853-ee15fc80-c896-11eb-879f-f0806147e754.png)

- **Membros privados**: √© a forma normal para os atributos de classe que *n√£o ter√° subclasses*, mas n√£o √© adequada para os m√©todos de acesso (*Setters e Getters*).

![code](https://user-images.githubusercontent.com/61624336/121272705-0d178d00-c89d-11eb-9970-8d1383ec8086.png)

- **Membros protegidos**: √© a forma normal para os atributos de classe que ter√£o subclasses, mas tamb√©m n√£o √© adequada para os m√©todos de acesso *(Setters e Getters)*.

![code](https://user-images.githubusercontent.com/61624336/121273141-e7d74e80-c89d-11eb-9aa5-9f2fa4ec09e6.png)

Como vimos, o encapsulamento determina a **visibilidade de classes** ou de **seus membros**. √â comum protegermos os atributos de uma classe para que eles n√£o tenham *acesso direto*, e os *valores* a serem atribu√≠dos possam ser analisados por um m√©todo antes da atribui√ß√£o.

## ‚òï Pacotes üì¶
**Pacotes**, em Java, s√£o usados para facilitar o armazenamento e controle da biblioteca de classes. Como vimos at√© o momento, nossa biblioteca de classes vem crescendo e, dessa forma, v√°rias classes foram criadas e est√£o em diferentes locais. √â necess√°rio organizarmos nossas classes e, para isso, podemos usar os pacotes.

Pacotes n√£o passam de uma *estrutura de diret√≥rios* em que colocamos as nossas classes por afinidade. Por afinidade devemos entender que s√£o classes com algum tipo de ader√™ncia, similaridade ou que pertencem a um mesmo assunto.

No projeto criado para nossos exemplos dessa unidade, temos a seguinte estrutura:

![img2](https://user-images.githubusercontent.com/61624336/121275698-a0ec5780-c8a3-11eb-88a6-c28e4d0c7e00.jpg)

Note que temos apenas um pacote, o pacote default do projeto, e todas as classes est√£o juntas. Para criarmos novos pacotes, basta clicar sobre o projeto e escolher **New / Package**, como voc√™ pode observar na imagem a seguir.

![img3](https://user-images.githubusercontent.com/61624336/121276412-fffe9c00-c8a4-11eb-8549-4e824106555e.jpg)

Como foram criados tr√™s grupos de classes para os exemplos, vamos separar nossas classes em tr√™s pacotes, sendo eles: **parte1**, **parte2** e **parte3**.

![img4](https://user-images.githubusercontent.com/61624336/121276493-26243c00-c8a5-11eb-8a82-170795faebd5.jpg)

Basta agora arrastar as classes para seus respectivos pacotes.

![img5](https://user-images.githubusercontent.com/61624336/121276533-376d4880-c8a5-11eb-8050-f7d634527a1c.jpg)

Fisicamente, os arquivos ficar√£o dentro dos respectivos diret√≥rios, podendo ainda ser criados subpacotes. A separa√ß√£o em pacotes permite duas ou mais classes com o mesmo nome, bastando que elas estejam em diferentes pacotes.

![img6](https://user-images.githubusercontent.com/61624336/121278098-4f929700-c8a8-11eb-921e-30b7316796c9.jpg)
![img7](https://user-images.githubusercontent.com/61624336/121278091-4e616a00-c8a8-11eb-9dc9-b60bf69da76f.jpg)

Quando temos nossas classes separadas em pacotes, sempre que precisarmos us√°-las devemos importar a(s) classe(s) de seus respectivos pacotes.

Dessa forma, criamos um pacote apenas para as aplica√ß√µes e transferimos as aplica√ß√µes de encapsulamento para esse pacote. Note que as classes agora est√£o apresentando erros.

![img8](https://user-images.githubusercontent.com/61624336/121278175-751fa080-c8a8-11eb-8d52-bde6c5a6e7a6.jpg)

Isso ocorre porque as aplica√ß√µes n√£o est√£o encontrando as respectivas classes e, para que elas sejam encontradas, devemos importar as classes:

#### Para a aplica√ß√£o do primeiro exemplo:

<pre>import parte1.Exemplo;</pre>

#### Para a aplica√ß√£o do segundo exemplo:

<pre>import parte2.Tributos;</pre>

Outro ponto importante √© que os atributos das classes **Exemplo** e **Tributos** estavam com a visibilidade padr√£o e, para continuar a funcionar, √© necess√°rio alterar a visibilidade dos atributos para p√∫blica (public), uma vez que essas classes agora est√£o em diferentes pacotes.

<hr>

<h1 align="center">Cap 08: ‚òï Classes abstratas e interfaces üíà</h1>

As **classes abstratas** s√£o usadas como moldes para a cria√ß√£o de outras classes e podem encapsular atributos e comportamentos comuns. J√° **interface** √© um recurso muito utilizado em Java. Uma classe pode implementar v√°rias interfaces.

## Modificadores: static e final

Anteriormente, conhecemos os *modificadores de acesso* ou de *visibilidade* (Encapsulamento). Agora iremos conhecer mais alguns modificadores que podem ser aplicados sobre classes, no caso do final e sobre membros (Atributos e M√©todos) de uma classe. Esses modificadores, como o nome j√° diz, servem para alterar a forma de uso de classes, m√©todos e/ou atributos.

## Refer√™ncia .this

O uso do <code>this</code> em Java √© para ajudar na quest√£o das refer√™ncias (endere√ßamento) de mem√≥ria. O <code>this</code> √© um ponteiro (vari√°vel que armazena endere√ßo de mem√≥ria) de forma impl√≠cita. Java n√£o possui *endere√ßamento direto de mem√≥ria* (endere√ßamento expl√≠cito), apenas o *endere√ßamento indireto* (impl√≠cito) de mem√≥ria. A refer√™ncia <code>this</code> ent√£o √© uma refer√™ncia impl√≠cita ao endere√ßamento de mem√≥ria de um objeto.

A refer√™ncia <code>this</code> altera a identifica√ß√£o do objeto pelo seu identificador (nome) e pelo endere√ßo de mem√≥ria do objeto, e *s√≥ pode referenciar membros da classe*, ou seja, somente faz refer√™ncia a *atributos e m√©todos*.

Dessa forma, podemos substituir o nome do objeto pela sua refer√™ncia, e tamb√©m separar quando tem o mesmo nome vari√°veis e atributos:

![code](https://user-images.githubusercontent.com/61624336/121282961-be73ee00-c8b0-11eb-972f-9e15749a9efa.png)

Nota: O <code>this</code> separa os membros da classe das demais vari√°veis auxiliares e par√¢metros da classe.

## O modificador: static
Este modificador pode ser aplicado sobre atributos e m√©todos e transforma o atributo ou m√©todo para a forma ‚Äúcompartilhada‚Äù.

### O modificador static aplicado a um atributo
Este modificador ao ser aplicado em um atributo de uma classe modifica este atributo de objeto (ou de inst√¢ncia) para um atributo de classe1.

Exemplo 1 - Aplica√ß√£o com o compartilhamento de um valor: <code>private static double valorDolar</code>

### Classe Cotacao (pacote: biblioteca):

![code](https://user-images.githubusercontent.com/61624336/121292097-c5eec380-c8bf-11eb-8075-fdb4d0abc996.png)

### Classe Exemplo1 (pacote: aplicacao):

![code](https://user-images.githubusercontent.com/61624336/121293518-22eb7900-c8c2-11eb-9b57-dd1021a736f8.png)

### Execu√ß√£o:

<pre>
Qual √© o Valor do d√≥lar ?

3.82

Quantos reais para a convers√£o ?

1000

Valor do d√≥lar :3.82

Covers√£o de Real para d√≥lar : US$ 261,78

Valor do d√≥lar :4.15

Covers√£o de Real para d√≥lar : US$ 240,96

Valor do d√≥lar :4.15

Covers√£o de Real para d√≥lar : US$ 240,96
</pre>

### Notas:

1. Primeiramente foi utilizado valor de R$ 3,82 para a cota√ß√£o do d√≥lar, com a leitura atrav√©s do teclado para o objeto cot_1, e foi calculada a convers√£o do valor de R$ 1000,00, resultando em: US$ 261,78;

2. Depois, foi criado o objeto cot_2, com o valor da cota√ß√£o do d√≥lar definido atrav√©s do m√©todo construtor em R$ 4,15, e foi mantido o mesmo valor de R$ 1000,00 para a convers√£o;

3. Ambos os objetos deram o mesmo resultado porque o valor do d√≥lar para a convers√£o era o mesmo, de R$ 4,15. Isso ocorreu pois, ao alterar o valor da cota√ß√£o do d√≥lar atrav√©s do objeto cot_2, o objeto cot_1 tamb√©m foi afetado, j√° que o atributo valorDolar √© compartilhado: <code>private static double valorDolar;</code>

Como o atributo valorDolar √© compartilhado, o atributo deixa de ser um atributo de objeto (propriedade) com valor pr√≥prio a cada objeto, e passa a ser um atributo de classe, ou seja, passa a ser compartilhado por todas as inst√¢ncias. Internamente √© criado um ponteiro impl√≠cito em que todos os atributos compartilhados da classe apontam para o mesmo endere√ßo de mem√≥ria. Por isso, qualquer objeto que realize uma altera√ß√£o em um atributo compartilhado afetar√° todos os demais objetos criados a partir da mesma classe na aplica√ß√£o.

A refer√™ncia <code>this</code> n√£o pode ser usada com *atributos est√°ticos (static)*, apenas *atributos n√£o compartilhados*, porque a refer√™ncia dos atributos compartilhados n√£o pertence ao objeto, mas sim √† classe.

Exemplo 2 - Aplica√ß√£o com um contador de objetos criados: <code>private static int contador</code>

### Classe Teste (pacote: biblioteca):

![code](https://user-images.githubusercontent.com/61624336/121296690-701e1980-c8c7-11eb-8295-bfc760c66398.png)

### Classe Exemplo2 (pacote: aplicacao)

![code](https://user-images.githubusercontent.com/61624336/121296809-a196e500-c8c7-11eb-8c75-cb8a53954b57.png)

<pre>
Contador =1

Contador =2

Contador =3

Contador =4

Contador =5

Contador =5
</pre>

## Notas:

1. Foram criados cinco objetos, mas em nenhum caso foi feito um acesso direto para o atributo contador; cada objeto, ao ser criado, incrementava o contador;

2. Conforme foram sendo criados os objetos, o valor compartilhado do atributo contador ia sendo atualizado para todos os objetos;

3. Ap√≥s a cria√ß√£o do 5¬∫ objeto, o objeto t5, o atributo do objeto t1, assim como os demais, compartilhavam o mesmo local de mem√≥ria para buscar o valor do atributo; por isso, todos os objetos encerraram a aplica√ß√£o retornando o valor 5 para o atributo contador compartilhado (static).

# Primefaces
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Pf-logo.png" height="157"></div><br \>

# ‚òï Java RoadMap üó∫Ô∏è
![1643485463767](https://user-images.githubusercontent.com/61624336/155857899-572ed5c4-cdb1-4171-9865-b8a8de7f8377.jpg)






























































































































































































































































<hr>
<div align="left"><a href="https://github.com/IsaacAlves7/java-programming"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/java_button_icon_151928.png" height="47"></a></div>
